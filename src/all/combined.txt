

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\bullet.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\bullet.js =====

import { ctx } from "./core.js";
import { dist } from "./utils.js";
import { enemies } from "./state.js";
import { spawnExplosion, spawnHit } from "./effects.js";

export class Bullet {
  constructor(x, y, target, spec) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.speed = spec.bulletSpeed;
    this.dmg = spec.dmg;
    this.splash = spec.splash || 0;
    this.color = spec.color;
    this.dead = false;

    // Ice properties (will be undefined for non-ice bullets)
    this.isIce = spec.isIce;
    this.slowAmount = spec.slowAmount;
    this.slowDuration = spec.slowDuration;
    this.freezeChance = spec.freezeChance;
  }

  update(dt) {
    if (!this.target || this.target.dead) {
      this.dead = true;
      return;
    }

    const tp = this.target.pos;
    const a = Math.atan2(tp.y - this.y, tp.x - this.x);
    const vx = Math.cos(a) * this.speed,
      vy = Math.sin(a) * this.speed;
    this.x += vx * dt;
    this.y += vy * dt;

    if (Math.hypot(tp.x - this.x, tp.y - this.y) < 10) {
      if (this.splash > 0) {
        for (const e of enemies) {
          const d = dist({ x: this.x, y: this.y }, e.pos);
          if (d <= this.splash) e.damage(this.dmg * (1 - d / this.splash));
        }
        spawnExplosion(this.x, this.y, this.splash, this.color);
      } else {
        this.target.damage(this.dmg);

        // Apply ice effects if this is an ice bullet
        if (this.isIce) {
          this.applyIceEffect(this.target);
        }

        spawnHit(this.x, this.y, this.color);
      }
      this.dead = true;
    }
  }

  applyIceEffect(enemy) {
    // Apply slow effect
    if (enemy.slowEffect) {
      // Refresh duration if already slowed
      enemy.slowEffect.duration = this.slowDuration;
    } else {
      // Create new slow effect
      enemy.slowEffect = {
        originalSpeed: enemy.speed,
        amount: this.slowAmount,
        duration: this.slowDuration,
      };
      enemy.speed *= 1 - this.slowAmount;
    }

    // Apply freeze chance
    if (Math.random() < this.freezeChance && !enemy.frozen) {
      enemy.frozen = true;
      enemy.speed = 0;

      // Set timeout to unfreeze
      setTimeout(() => {
        if (!enemy.dead) {
          enemy.frozen = false;
          enemy.speed = enemy.slowEffect
            ? enemy.slowEffect.originalSpeed * (1 - enemy.slowEffect.amount)
            : enemy.slowEffect.originalSpeed;
        }
      }, this.slowDuration * 500); // Freeze for half the slow duration
    }

    // Visual ice effect on enemy
    enemy.iceEffect = true;
    enemy.iceEffectTime = this.slowDuration;
  }

  draw() {
    ctx.fillStyle = this.color;

    // Different appearance for ice bullets
    if (this.isIce) {
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Ice crystal effect
      ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
      ctx.beginPath();
      ctx.moveTo(this.x, this.y - 5);
      ctx.lineTo(this.x + 3.5, this.y);
      ctx.lineTo(this.x, this.y + 5);
      ctx.lineTo(this.x - 3.5, this.y);
      ctx.closePath();
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\config.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\config.js =====

import { GunTower } from "./towers/GunTower.js";
import { CannonTower } from "./towers/CannonTower.js";
import { DoubleCannonTower } from "./towers/DoubleCannonTower.js";
import { LaserTower } from "./towers/LaserTower.js";
import { IceTower } from "./towers/IceTower.js";
import { TeslaTower } from "./towers/TeslaTower.js";
import { PoisonTower } from "./towers/PoisonTower.js";
import { MissileTower } from "./towers/MissileTower.js";

export const TOWER_TYPES = {
  gun: {
    name: "Gunner",
    cost: 80,
    range: 120,
    fireRate: 6,
    dmg: 12,
    bulletSpeed: 340,
    color: "#6cf",
    class: GunTower,
  },
  cannon: {
    name: "Cannon",
    cost: 120,
    range: 140,
    fireRate: 1.2,
    dmg: 55,
    splash: 60,
    bulletSpeed: 260,
    color: "#f6c66a",
    class: CannonTower,
  },
  doubleCanon: {
    name: "Double Canon",
    cost: 160,
    range: 120,
    fireRate: 0.9,
    dmg: 75,
    splash: 55,
    bulletSpeed: 240,
    color: "#f00",
    class: DoubleCannonTower,
  },
  laser: {
    name: "Laser",
    cost: 250,
    range: 150,
    fireRate: 12,
    dmg: 5,
    beam: true,
    color: "#ff69e0",
    class: LaserTower,
  },
  ice: {
    // Add Ice Tower
    name: "Ice Tower",
    cost: 180,
    range: 130,
    fireRate: 2.5,
    dmg: 8,
    slowAmount: 0.6,
    slowDuration: 3,
    freezeChance: 0.2,
    bulletSpeed: 300,
    color: "#6cfaff",
    class: IceTower,
  },
  tesla: {
    name: "Tesla Tower",
    cost: 220,
    range: 140,
    fireRate: 1.8,
    dmg: 25,
    chainCount: 3, // Jumps to 3 additional targets
    chainRange: 80, // Range for chain jumps
    stunChance: 0.1, // 30% chance to stun
    stunDuration: 1, // seconds
    color: "#9d4edd",
    class: TeslaTower,
  },
  poison: {
    // Add Poison Tower
    name: "Poison Tower",
    cost: 190,
    range: 110,
    fireRate: 1.5,
    dmg: 15,
    dotDamage: 8, // Damage per second
    dotDuration: 4, // seconds
    spreadRange: 60, // Range for poison spread
    cloudDuration: 3, // Lingering cloud duration
    color: "#4CAF50",
    class: PoisonTower,
  },
  missile: {
    name: "Missile Tower",
    cost: 280,
    range: 160,
    fireRate: 0.8,
    dmg: 70,
    splash: 80, // Splash damage radius
    bulletSpeed: 180, // Slower but homing
    homingStrength: 0.1, // How strongly missiles home in
    retarget: true, // Can retarget if original target dies
    color: "#FF5722",
    class: MissileTower,
  },
};


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\core.js =====

// Canvas, sizing and basic exports
export const DPR = Math.min(2, window.devicePixelRatio || 1);
export const TILE = 40;
export let GRID_W = 0;
export let GRID_H = 0;
export let W = 0;
export let H = 0;

export const canvas = document.createElement("canvas");
canvas.id = "game";
canvas.style.width = "100%";
canvas.style.maxWidth = "1100px";
canvas.style.height = "650px";
canvas.style.display = "block";
canvas.style.margin = "24px auto";
canvas.style.background = "#0b0f1a";
canvas.style.borderRadius = "16px";
canvas.style.boxShadow =
  "0 30px 60px rgba(0,0,0,0.35), inset 0 0 120px rgba(0,180,255,0.04)";
document.body.appendChild(canvas);
export const ctx = canvas.getContext("2d");

function computeGrid() {
  GRID_W = Math.floor(canvas.clientWidth / TILE);
  GRID_H = Math.floor(canvas.clientHeight / TILE);
  W = GRID_W * TILE;
  H = GRID_H * TILE;
}

export function resize() {
  const w = Math.min(window.innerWidth - 32, 1100);
  const h = 650;
  canvas.width = Math.floor(w * DPR);
  canvas.height = Math.floor(h * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  computeGrid();
}
window.addEventListener("resize", resize);

export function syncLogicalSize() {
  computeGrid();
  canvas.width = Math.floor(W * DPR);
  canvas.height = Math.floor(H * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}



// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\effects.js =====

import { particles, beams, circles, pulses } from "./state.js";
import { rand, TAU, clamp } from "./utils.js";
import { ctx } from "./core.js";

export function spawnMuzzle(x, y, rot, color) {
  for (let i = 0; i < 6; i++)
    particles.push({
      x,
      y,
      vx: Math.cos(rot + rand(0.5, -0.25)) * rand(220, 60),
      vy: Math.sin(rot + rand(0.5, -0.25)) * rand(220, 60),
      life: rand(0.15, 0.06),
      r: rand(2.5, 1),
      c: color,
    });
}
export function spawnHit(x, y, color) {
  for (let i = 0; i < 8; i++)
    particles.push({
      x,
      y,
      vx: rand(180, -180),
      vy: rand(180, -180),
      life: rand(0.25, 0.12),
      r: rand(2.5, 1),
      c: color,
    });
}
export function spawnExplosion(x, y, R, color) {
  for (let i = 0; i < 18; i++) {
    const a = rand(TAU);
    particles.push({
      x,
      y,
      vx: Math.cos(a) * rand(220, 60),
      vy: Math.sin(a) * rand(220, 60),
      life: rand(0.45, 0.25),
      r: rand(4, 2),
      c: color,
    });
  }
  circles.push({ x, y, R, life: 0.3, c: color });
}
export function spawnDeath(p) {
  for (let i = 0; i < 16; i++) {
    const a = rand(TAU);
    particles.push({
      x: p.x,
      y: p.y,
      vx: Math.cos(a) * rand(240, 80),
      vy: Math.sin(a) * rand(240, 80),
      life: rand(0.55, 0.25),
      r: rand(4, 2),
      c: "#9ff",
    });
  }
  pulses.push({ text: "+$", x: 0, y: 0, life: 1.2, c: "#9f9" });
}
export function spawnBeam(a, b, color) {
  beams.push({ a: { ...a }, b: { ...b }, life: 0.06, c: color });
}

export function updateEffects(dt) {
  for (const p of particles) {
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= dt;
    p.vx *= 0.98;
    p.vy *= 0.98;
  }
  for (let i = particles.length - 1; i >= 0; i--)
    if (particles[i].life <= 0) particles.splice(i, 1);
  for (const b of beams) {
    b.life -= dt;
  }
  for (let i = beams.length - 1; i >= 0; i--)
    if (beams[i].life <= 0) beams.splice(i, 1);
  for (const c of circles) {
    c.life -= dt;
  }
  for (let i = circles.length - 1; i >= 0; i--)
    if (circles[i].life <= 0) circles.splice(i, 1);
}

export function drawEffects() {
  // Beams
  for (const b of beams) {
    if (b.type === "lightning") {
      // Call the standalone function, not this.drawLightningArc
      drawLightningArc(b.a, b.b, b.c, b.life / 0.15);
    } else {
      // Regular beam drawing code
      ctx.strokeStyle = b.c;
      ctx.globalAlpha = clamp(b.life / 0.06, 0, 1);
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(b.a.x, b.a.y);
      ctx.lineTo(b.b.x, b.b.y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }
  // Expanding shock circles
  for (const c of circles) {
    if (c.type === "poison") {
      const alpha = clamp((c.life / c.R) * 0.3, 0, 0.3); // Fade based on remaining life
      ctx.fillStyle = `rgba(76, 175, 80, ${alpha})`;
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.R * (1 - c.life / c.R), 0, TAU);
      ctx.fill();
    } else {
      // Regular circle drawing code
      const a = clamp(c.life / 0.3, 0, 1);
      ctx.strokeStyle = c.c;
      ctx.globalAlpha = a;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(c.x, c.y, (1 - a) * c.R, 0, TAU);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }
  // Particles
  for (const p of particles) {
    ctx.globalAlpha = clamp(p.life * 4, 0, 1);
    ctx.fillStyle = p.c;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, TAU);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

export function spawnLightningArc(start, end, color) {
  beams.push({
    a: { ...start },
    b: { ...end },
    life: 0.15,
    c: color,
    type: "lightning",
    jagged: true,
  });
}

export function spawnElectricExplosion(x, y) {
  circles.push({
    x,
    y,
    R: 25,
    life: 0.4,
    c: "#e0aaff",
    type: "electric",
  });

  for (let i = 0; i < 12; i++) {
    const angle = Math.random() * TAU;
    particles.push({
      x,
      y,
      vx: Math.cos(angle) * rand(300, 100),
      vy: Math.sin(angle) * rand(300, 100),
      life: rand(0.4, 0.2),
      r: rand(3, 1),
      c: "#e0aaff",
      gravity: 0.1,
      fade: 0.85,
    });
  }
}

function drawLightningArc(start, end, color, progress) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.globalAlpha = clamp(progress, 0, 1);

  const segments = 8;
  const dx = (end.x - start.x) / segments;
  const dy = (end.y - start.y) / segments;

  ctx.beginPath();
  ctx.moveTo(start.x, start.y);

  for (let i = 1; i <= segments; i++) {
    const x = start.x + dx * i;
    const y = start.y + dy * i;
    const offsetX = (Math.random() - 0.5) * 15 * (1 - progress);
    const offsetY = (Math.random() - 0.5) * 15 * (1 - progress);
    ctx.lineTo(x + offsetX, y + offsetY);
  }

  ctx.stroke();
  ctx.globalAlpha = 1;
}

export function spawnPoisonCloud(x, y, duration, radius) {
  // Create a lingering poison cloud effect
  circles.push({
    x,
    y,
    R: radius,
    life: duration,
    c: "#4CAF50",
    type: "poison",
    alpha: 0.3,
  });

  // Add poison particles
  for (let i = 0; i < 8; i++) {
    const angle = Math.random() * TAU;
    const distance = Math.random() * radius;

    particles.push({
      x: x + Math.cos(angle) * distance,
      y: y + Math.sin(angle) * distance,
      vx: (Math.random() - 0.5) * 20,
      vy: (Math.random() - 0.5) * 20,
      life: duration * 0.8,
      r: 2 + Math.random() * 2,
      c: "#4CAF50",
      gravity: -0.1, // Reverse gravity for rising effect
      fade: 0.97,
    });
  }
}

// Add to your existing effects.js:

export function spawnMissileExplosion(x, y, radius, color) {
  // Larger explosion for missiles
  for (let i = 0; i < 25; i++) {
    const a = rand(TAU);
    particles.push({
      x,
      y,
      vx: Math.cos(a) * rand(350, 100),
      vy: Math.sin(a) * rand(350, 100),
      life: rand(0.6, 0.3),
      r: rand(5, 2),
      c: color,
      gravity: 0.15,
      fade: 0.9,
    });
  }

  circles.push({
    x,
    y,
    R: radius,
    life: 0.5,
    c: color,
    type: "explosion",
  });

  // Shockwave effect
  circles.push({
    x,
    y,
    R: radius * 1.5,
    life: 0.4,
    c: "#FF9800",
    type: "shockwave",
  });
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\enemy.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\enemy.js =====

import { ctx } from "./core.js";
import { clamp, rand } from "./utils.js";
import { pointAt, totalLen } from "./path.js";
import { spawnDeath, spawnExplosion } from "./effects.js";
import { state } from "./state.js";

// Enemy type definitions - encapsulated with all their properties
export const ENEMY_TYPES = {
  basic: {
    name: "Scout",
    baseHp: 100,
    baseSpeed: 50,
    baseReward: 8,
    radius: 12,
    color: "#7df",
    glowColor: "#48f",
    detailColor: "#5ac",
    tierIndicator: 0,
    spawnWeight: 1.0,
    description: "Basic enemy unit",
  },
  brute: {
    name: "Brute",
    baseHp: 180,
    baseSpeed: 40,
    baseReward: 15,
    radius: 16,
    color: "#f96",
    glowColor: "#f63",
    detailColor: "#d54",
    tierIndicator: 1,
    spawnWeight: 0.7,
    description: "Slow but tough enemy",
  },
  swift: {
    name: "Swift",
    baseHp: 80,
    baseSpeed: 70,
    baseReward: 12,
    radius: 10,
    color: "#9f6",
    glowColor: "#6f3",
    detailColor: "#5d4",
    tierIndicator: 2,
    spawnWeight: 0.8,
    description: "Fast but fragile enemy",
  },
  elite: {
    name: "Elite",
    baseHp: 250,
    baseSpeed: 45,
    baseReward: 25,
    radius: 14,
    color: "#f6f",
    glowColor: "#c3f",
    detailColor: "#a3c",
    tierIndicator: 3,
    spawnWeight: 0.4,
    description: "Powerful elite enemy",
  },
};

// Difficulty scaling function
let difficultyMult = () => 1 + state.wave * 0.15;

export class Enemy {
  constructor(type = "basic", tier = 0) {
    const enemyType = ENEMY_TYPES[type] || ENEMY_TYPES.basic;

    this.type = type;
    this.t = 0;
    this.speed = enemyType.baseSpeed * difficultyMult();
    this.maxHp = (enemyType.baseHp + tier * 40) * difficultyMult();
    this.hp = this.maxHp;
    this.reward = Math.round(
      (enemyType.baseReward + tier * 2) * difficultyMult()
    );
    this.r = enemyType.radius;
    this.color = enemyType.color;
    this.glowColor = enemyType.glowColor;
    this.detailColor = enemyType.detailColor;
    this.tierIndicator = enemyType.tierIndicator;
    this.dead = false;
    this.animationOffset = rand(Math.PI * 2);
    this.tier = tier;

    this.slowEffect = null;
    this.frozen = false;
    this.iceEffect = false;
    this.iceEffectTime = 0;

    // Add these properties to the Enemy class constructor:
    this.stunned = false;
    this.originalSpeed = this.speed;
    this.electricEffect = false;
    this.electricEffectTime = 0;

    // Add these properties to the Enemy class constructor:
    this.poisoned = false;
    this.poisonDamage = 0;
    this.poisonDuration = 0;
    this.poisonStartTime = 0;
  }

  get pos() {
    return pointAt(this.t);
  }

  update(dt) {
    if (this.dead) return;
    this.t += (this.speed * dt) / totalLen;
    this.animationOffset += dt * 3;

    if (this.t >= 1) {
      this.dead = true;
      state.lives = Math.max(0, state.lives - 1);
      spawnExplosion(this.pos.x, this.pos.y, 20, "#f44");
    }

    if (this.slowEffect) {
      this.slowEffect.duration -= dt;
      if (this.slowEffect.duration <= 0) {
        this.speed = this.slowEffect.originalSpeed;
        this.slowEffect = null;
      }
    }

    if (this.iceEffect) {
      this.iceEffectTime -= dt;
      if (this.iceEffectTime <= 0) {
        this.iceEffect = false;
      }
    }

    if (this.stunned) {
      this.speed = 0;
    }

    if (this.electricEffect) {
      this.electricEffectTime -= dt;
      if (this.electricEffectTime <= 0) {
        this.electricEffect = false;
      }
    }

    if (this.poisoned) {
      const elapsed = (performance.now() - this.poisonStartTime) / 1000;
      if (elapsed >= this.poisonDuration) {
        this.poisoned = false;
      }
    }
  }

  damage(d) {
    if (this.dead) return;
    this.hp -= d;
    if (this.hp <= 0) {
      this.dead = true;
      state.money += this.reward;
      spawnDeath(this.pos);
    }
  }

  draw() {
    if (this.dead) return;
    const { x, y } = this.pos;
    const TAU = Math.PI * 2;
    const { r } = this;

    if (this.poisoned) {
      const elapsed = (performance.now() - this.poisonStartTime) / 1000;
      const progress = elapsed / this.poisonDuration;
      const alpha = 0.5 - progress * 0.3; // Fade out as poison wears off

      ctx.fillStyle = `rgba(76, 175, 80, ${alpha})`;
      ctx.beginPath();
      ctx.arc(x, y, this.r + 2, 0, TAU);
      ctx.fill();

      // Poison bubbles effect
      if (Math.random() < 0.3) {
        const bubbleX = x + (Math.random() - 0.5) * this.r * 1.5;
        const bubbleY = y + (Math.random() - 0.5) * this.r * 1.5;
        const size = 1 + Math.random() * 1.5;

        ctx.fillStyle = "rgba(165, 214, 167, 0.8)";
        ctx.beginPath();
        ctx.arc(bubbleX, bubbleY, size, 0, TAU);
        ctx.fill();
      }
    }

    if (this.electricEffect || this.stunned) {
      const alpha = this.stunned ? 0.7 : 0.4;
      ctx.fillStyle = `rgba(157, 78, 221, ${alpha})`;
      ctx.beginPath();
      ctx.arc(x, y, this.r + 3, 0, TAU);
      ctx.fill();

      // Draw electric arcs on stunned enemies
      if (this.stunned) {
        ctx.strokeStyle = "rgba(224, 170, 255, 0.8)";
        ctx.lineWidth = 1.5;

        for (let i = 0; i < 3; i++) {
          const angle1 = Math.random() * TAU;
          const angle2 = angle1 + (Math.random() - 0.5) * Math.PI;
          const dist1 = this.r * (0.5 + Math.random() * 0.5);
          const dist2 = this.r * (0.8 + Math.random() * 0.2);

          ctx.beginPath();
          ctx.moveTo(
            x + Math.cos(angle1) * dist1,
            y + Math.sin(angle1) * dist1
          );

          // Create jagged lightning effect
          const segments = 3;
          const dx =
            (Math.cos(angle2) * dist2 - Math.cos(angle1) * dist1) / segments;
          const dy =
            (Math.sin(angle2) * dist2 - Math.sin(angle1) * dist1) / segments;

          for (let j = 1; j <= segments; j++) {
            const segX = x + Math.cos(angle1) * dist1 + dx * j;
            const segY = y + Math.sin(angle1) * dist1 + dy * j;
            const offsetX = (Math.random() - 0.5) * 5;
            const offsetY = (Math.random() - 0.5) * 5;
            ctx.lineTo(segX + offsetX, segY + offsetY);
          }

          ctx.stroke();
        }
      }
    }

    // Glow effect
    const grd = ctx.createRadialGradient(x, y, 4, x, y, r + 10);
    grd.addColorStop(0, this.glowColor);
    grd.addColorStop(1, "rgba(0,255,255,0.0)");
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(x, y, r + 8, 0, TAU);
    ctx.fill();

    // Main body
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, TAU);
    ctx.fill();

    // Enemy details - animated spikes/features
    ctx.strokeStyle = this.detailColor;
    ctx.lineWidth = 2;
    ctx.beginPath();

    if (this.iceEffect || this.frozen) {
      const alpha = this.frozen ? 0.6 : 0.3;
      ctx.fillStyle = `rgba(180, 230, 255, ${alpha})`;
      ctx.beginPath();
      ctx.arc(x, y, this.r + 2, 0, TAU);
      ctx.fill();

      if (this.frozen) {
        // Draw ice cracks
        ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x - this.r * 0.7, y - this.r * 0.3);
        ctx.lineTo(x + this.r * 0.5, y + this.r * 0.4);
        ctx.moveTo(x + this.r * 0.2, y - this.r * 0.6);
        ctx.lineTo(x - this.r * 0.3, y + this.r * 0.7);
        ctx.stroke();
      }
    }

    const spikeCount = 6 + this.tier * 2;
    for (let i = 0; i < spikeCount; i++) {
      const angle = (i * TAU) / spikeCount + this.animationOffset;
      const spikeLength = 4 + Math.sin(this.animationOffset + i) * 2;
      const startX = x + Math.cos(angle) * (r - 2);
      const startY = y + Math.sin(angle) * (r - 2);
      const endX = x + Math.cos(angle) * (r + spikeLength);
      const endY = y + Math.sin(angle) * (r + spikeLength);

      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
    }
    ctx.stroke();

    // Core/eye
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    const eyeSize = 4 - this.tier * 0.5;
    ctx.arc(x, y, Math.max(2, eyeSize), 0, TAU);
    ctx.fill();

    // Tier indicator
    if (this.tier > 0) {
      ctx.fillStyle = "#ff0";
      for (let i = 0; i < this.tier; i++) {
        ctx.beginPath();
        ctx.arc(x - 6 + i * 4, y - r - 6, 2, 0, TAU);
        ctx.fill();
      }
    }

    // Health bar
    const w = 28,
      h = 5;
    const p = clamp(this.hp / this.maxHp, 0, 1);
    ctx.fillStyle = "#132";
    ctx.fillRect(x - w / 2, y - r - 14, w, h);
    ctx.fillStyle = p > 0.5 ? "#6f6" : p > 0.25 ? "#fd6" : "#f66";
    ctx.fillRect(x - w / 2, y - r - 14, w * p, h);
  }
}

// Helper function to get enemy types by wave
export function getEnemiesForWave(wave) {
  const enemies = [];
  const totalCount = 8 + wave * 2;

  // Determine which enemy types can spawn this wave
  const availableTypes = [];

  if (wave >= 1) availableTypes.push("basic");
  if (wave >= 2) availableTypes.push("brute");
  if (wave >= 3) availableTypes.push("swift");
  if (wave >= 5) availableTypes.push("elite");

  // Calculate tier based on wave
  const tier = Math.floor((wave - 1) / 1.5);

  // Distribute enemies based on type weights
  for (let i = 0; i < totalCount; i++) {
    let type;

    // For early waves, use only basic enemies
    if (wave < 2) {
      type = "basic";
    } else {
      // Weighted random selection for later waves
      const weights = availableTypes.map((t) => ENEMY_TYPES[t].spawnWeight);
      const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
      let random = Math.random() * totalWeight;

      for (let j = 0; j < availableTypes.length; j++) {
        random -= weights[j];
        if (random <= 0) {
          type = availableTypes[j];
          break;
        }
      }
    }

    enemies.push({ type, tier });
  }

  return enemies;
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\entities.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\entities.js =====

export { Enemy } from "./enemy.js";
export { BaseTower as Tower } from "./towers/BaseTower.js";
export { Bullet } from "./bullet.js";
export { Missile } from "./missile.js";


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\helpers.js =====

import { ctx } from "./core.js";

export function roundRect(
  x,
  y,
  w,
  h,
  r = 4,
  fillColor = "#000",
  fill = true,
  strokeColor = null
) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  if (fill) (ctx.fillStyle = fillColor), ctx.fill();
  if (strokeColor) (ctx.strokeStyle = strokeColor), ctx.stroke();
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\index.mjs =====

import { canvas, ctx, TILE, resize, syncLogicalSize } from "./core.js";
import { state, enemies, towers, projectiles, particles } from "./state.js";
import { rand, clamp, dist, TAU, removeFromArray, pulse } from "./utils.js";
import { TOWER_TYPES } from "./config.js";
import { initPath, path, blocked, totalLen } from "./path.js";
import { Enemy, Tower, Bullet } from "./entities.js";
import {
  spawnMuzzle,
  spawnHit,
  spawnExplosion,
  spawnDeath,
  spawnBeam,
  updateEffects,
  drawEffects,
} from "./effects.js";
import { spawner, startNextWave } from "./spawner.js";
import {
  drawBackground,
  drawTopbar,
  drawShop,
  drawGhost,
  drawInspector,
  getShopButtons,
} from "./ui.js";
import { ui } from "./state.js";

// Ensure sizes
resize();
syncLogicalSize();
initPath();

// Mouse state with drag support
let mouse = {
  x: 0,
  y: 0,
  gx: 0,
  gy: 0,
  down: false,
  draggingTower: false,
  dragStartX: 0,
  dragStartY: 0,
};

// Add this after the existing mouse event listeners
canvas.addEventListener("wheel", (e) => {
  // Only handle wheel events in the shop area
  if (mouse.y > ctx.canvas.clientHeight - 100) {
    e.preventDefault();

    // Scroll the shop
    ui.shopScrollOffset += e.deltaY > 0 ? 100 : -100;
    ui.shopScrollOffset = Math.max(
      0,
      Math.min(ui.maxShopScroll, ui.shopScrollOffset)
    );
  }
});

// Also add touch support for mobile devices
let touchStartX = 0;
canvas.addEventListener("touchstart", (e) => {
  if (e.touches[0].clientY > ctx.canvas.clientHeight - 100) {
    touchStartX = e.touches[0].clientX;
    e.preventDefault();
  }
});

canvas.addEventListener("touchmove", (e) => {
  if (e.touches[0].clientY > ctx.canvas.clientHeight - 100) {
    const deltaX = touchStartX - e.touches[0].clientX;
    ui.shopScrollOffset += deltaX;
    ui.shopScrollOffset = Math.max(
      0,
      Math.min(ui.maxShopScroll, ui.shopScrollOffset)
    );
    touchStartX = e.touches[0].clientX;
    e.preventDefault();
  }
});

canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
  mouse.gx = Math.floor(mouse.x / TILE);
  mouse.gy = Math.floor(mouse.y / TILE);
  ui.hoveredTile = { gx: mouse.gx, gy: mouse.gy };
});

canvas.addEventListener("mousedown", (e) => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
  mouse.gx = Math.floor(mouse.x / TILE);
  mouse.gy = Math.floor(mouse.y / TILE);
  mouse.down = true;
  mouse.dragStartX = mouse.x;
  mouse.dragStartY = mouse.y;

  // Check if clicking on shop button
  // In the mousedown event handler, update the shop button detection:
  if (mouse.y > ctx.canvas.clientHeight - 100) {
    const buttons = getShopButtons(
      ctx.canvas.clientWidth,
      ctx.canvas.clientHeight
    );
    for (const b of buttons) {
      // Check if button is visible (within canvas bounds)
      if (b.x + b.w > 0 && b.x < ctx.canvas.clientWidth) {
        if (
          mouse.x >= b.x &&
          mouse.x <= b.x + b.w &&
          mouse.y >= b.y &&
          mouse.y <= b.y + b.h
        ) {
          const spec = TOWER_TYPES[b.key];
          // Don't allow selection if can't afford
          if (state.money < spec.cost) {
            pulse("Not enough money!", "#f66");
            return;
          }

          // If clicking the same tower type that's already selected, deselect it
          if (ui.selectedShopKey === b.key) {
            ui.selectedShopKey = null;
          } else {
            ui.selectedShopKey = b.key;
            ui.selectedTower = null;
          }
          mouse.draggingTower = false;
          return;
        }
      }
    }
    // Clicked in shop area but not on a button - deselect everything
    ui.selectedShopKey = null;
    ui.selectedTower = null;
    return;
  }

  // Check if clicking on existing tower
  const t = towers.find((t) => t.gx === mouse.gx && t.gy === mouse.gy);
  if (t) {
    // If clicking the same tower that's already selected, deselect it
    if (ui.selectedTower === t) {
      ui.selectedTower = null;
    } else {
      ui.selectedTower = t;
      ui.selectedShopKey = null;
    }
    mouse.draggingTower = false;
    return;
  }

  // Start dragging if we have a tower selected from shop
  if (ui.selectedShopKey) {
    mouse.draggingTower = true;
  } else {
    // Clicked on empty space - deselect everything
    ui.selectedTower = null;
  }
});

canvas.addEventListener("mouseup", (e) => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
  mouse.gx = Math.floor(mouse.x / TILE);
  mouse.gy = Math.floor(mouse.y / TILE);
  mouse.down = false;

  let towerPlaced = false; // Track if we placed a tower

  if (mouse.draggingTower) {
    // Place tower if tile is valid
    if (
      mouse.gx >= 0 &&
      mouse.gy >= 0 &&
      mouse.gy < Math.floor(ctx.canvas.clientHeight / TILE) - 2 &&
      !blocked.has(`${mouse.gx},${mouse.gy}`) &&
      !towers.some((t) => t.gx === mouse.gx && t.gy === mouse.gy)
    ) {
      const spec = TOWER_TYPES[ui.selectedShopKey];
      if (state.money >= spec.cost) {
        const spec = TOWER_TYPES[ui.selectedShopKey];
        towers.push(new spec.class(mouse.gx, mouse.gy, ui.selectedShopKey));
        state.money -= spec.cost;
        pulse(`-${spec.cost}`);

        // Clear selection after placing tower
        ui.selectedShopKey = null;
        ui.selectedTower = null;
        towerPlaced = true; // Mark that we placed a tower
      } else {
        pulse("Not enough $", "#f66");
      }
    }
  }

  mouse.draggingTower = false;

  // Only select tower if not dragging, not clicking on shop area, and didn't just place a tower
  if (
    !towerPlaced &&
    !mouse.draggingTower &&
    mouse.y <= ctx.canvas.clientHeight - 100
  ) {
    const t = towers.find((t) => t.gx === mouse.gx && t.gy === mouse.gy);
    if (t) {
      ui.selectedTower = t;
    } else {
      // Clicked on empty space - deselect everything
      ui.selectedTower = null;
      ui.selectedShopKey = null;
    }
  }
});

canvas.addEventListener("mouseleave", () => {
  ui.hoveredTile = null;
  mouse.down = false;
  mouse.draggingTower = false;
});

window.addEventListener("keydown", (e) => {
  if (!ui.selectedTower) return;
  if (e.key.toLowerCase() === "u") {
    const cost = ui.selectedTower.upgradeCost();
    if (state.money >= cost) {
      state.money -= cost;
      ui.selectedTower.level++;
      pulse(`Upgrade -${cost}`);
    } else pulse("Need more $", "#f66");
  }
  if (e.key.toLowerCase() === "s") {
    state.money += Math.round(ui.selectedTower.sellValue());
    removeFromArray(towers, ui.selectedTower);
    ui.selectedTower = null;
    pulse("Sold +$", "#9f9");
  }
});

// Main loop
let last = performance.now();
startNextWave();

function loop(ts) {
  const dt = Math.min(0.033, (ts - last) / 1000);
  last = ts;
  state.time += dt;
  if (!state.running) return;

  // Logic
  spawner(dt);
  for (const t of towers) t.update(dt, enemies);
  for (const b of projectiles) b.update(dt);
  for (const e of enemies) e.update(dt);
  updateEffects(dt);

  // Cull
  for (let i = projectiles.length - 1; i >= 0; i--)
    if (projectiles[i].dead) projectiles.splice(i, 1);
  for (let i = enemies.length - 1; i >= 0; i--)
    if (enemies[i].dead) enemies.splice(i, 1);
  if (state.lives <= 0) {
    gameOver();
    return;
  }

  // Draw
  drawBackground(state.time, path);
  drawTopbar(ctx.canvas.clientWidth);
  drawShop(ctx.canvas.clientWidth, ctx.canvas.clientHeight);

  // Show ghost when dragging or when hovering with a tower selected
  // BUT NOT when mouse is over the shop button area
  if (
    (mouse.draggingTower || (ui.hoveredTile && ui.selectedShopKey)) &&
    mouse.y <= ctx.canvas.clientHeight - 100
  ) {
    drawGhost(ui.hoveredTile, TILE, ui.selectedShopKey, mouse.draggingTower);
  }

  for (const t of towers) t.draw();
  for (const e of enemies) e.draw();
  for (const b of projectiles) b.draw();
  drawEffects();
  drawInspector(ui.selectedTower);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function gameOver() {
  drawBackground(state.time, path);
  drawTopbar(ctx.canvas.clientWidth);
  ctx.fillStyle = "rgba(10,20,36,0.86)";
  ctx.fillRect(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);
  ctx.fillStyle = "#fff";
  ctx.font = "800 48px Inter";
  ctx.textAlign = "center";
  ctx.fillText(
    "Game Over",
    ctx.canvas.clientWidth / 2,
    ctx.canvas.clientHeight / 2 - 10
  );
  ctx.font = "500 18px Inter";
  ctx.fillStyle = "#bfe7ff";
  ctx.fillText(
    `You reached wave ${state.wave}. Refresh to try again!`,
    ctx.canvas.clientWidth / 2,
    ctx.canvas.clientHeight / 2 + 28
  );
  ctx.textAlign = "start";
}

// Optional font loader (same as original)
(async () => {
  try {
    const inter = new FontFace(
      "Inter",
      "url(https://fonts.gstatic.com/s/inter/v13/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMaBZV.woff2)"
    );
    await inter.load();
    document.fonts.add(inter);
  } catch (e) {
    /* ignore */
  }
})();


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\missile.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\missile.js =====

import { ctx } from "./core.js";
import { dist } from "./utils.js";
import { enemies } from "./state.js";
import { spawnExplosion } from "./effects.js";
import { particles } from "./state.js";

export class Missile {
  constructor(x, y, target, spec, initialRotation = null) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.speed = spec.bulletSpeed;
    this.dmg = spec.dmg;
    this.splash = spec.splash;
    this.homingStrength = spec.homingStrength;
    this.retarget = spec.retarget;
    this.color = spec.color;
    this.dead = false;

    // Use provided rotation or calculate from target
    this.rotation =
      initialRotation !== null
        ? initialRotation
        : Math.atan2(target.pos.y - y, target.pos.x - x);

    this.trailParticles = [];
    this.smokeTimer = 0;
  }

  update(dt) {
    // Handle target death and retargeting
    if (!this.target || this.target.dead) {
      if (this.retarget) {
        this.findNewTarget();
        if (!this.target) {
          this.dead = true;
          return;
        }
      } else {
        this.dead = true;
        return;
      }
    }

    // Homing behavior
    const tp = this.target.pos;
    const desiredAngle = Math.atan2(tp.y - this.y, tp.x - this.x);
    const angleDiff =
      ((desiredAngle - this.rotation + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
    this.rotation += angleDiff * this.homingStrength;

    // Movement
    this.x += Math.cos(this.rotation) * this.speed * dt;
    this.y += Math.sin(this.rotation) * this.speed * dt;

    // Smoke trail
    this.smokeTimer -= dt;
    if (this.smokeTimer <= 0) {
      this.spawnSmokeTrail();
      this.smokeTimer = 0.05;
    }

    // Collision detection
    if (this.target && !this.target.dead) {
      const d = dist({ x: this.x, y: this.y }, this.target.pos);
      if (d < 15) {
        this.explode();
        this.dead = true;
      }
    }
  }

  findNewTarget() {
    let closest = null;
    let closestDist = Infinity;

    for (const e of enemies) {
      if (e.dead) continue;
      const d = dist({ x: this.x, y: this.y }, e.pos);
      if (d < closestDist) {
        closest = e;
        closestDist = d;
      }
    }

    this.target = closest;
  }

  explode() {
    // Main explosion
    spawnExplosion(this.x, this.y, this.splash, this.color);

    // Damage all enemies in splash radius
    for (const e of enemies) {
      if (e.dead) continue;
      const d = dist({ x: this.x, y: this.y }, e.pos);
      if (d <= this.splash) {
        const damageFactor = 1 - d / this.splash;
        e.damage(this.dmg * damageFactor);
      }
    }
  }

  spawnSmokeTrail() {
    for (let i = 0; i < 2; i++) {
      const angle = this.rotation + Math.PI + (Math.random() - 0.5) * 0.3;
      const speed = 20 + Math.random() * 30;
      const size = 2 + Math.random() * 2;
      const life = 0.8 + Math.random() * 0.4;

      particles.push({
        x: this.x - Math.cos(this.rotation) * 5,
        y: this.y - Math.sin(this.rotation) * 5,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: i === 0 ? "#888888" : "#FF5722", // Gray smoke and orange fire
        gravity: -0.05, // Smoke rises slightly
        fade: 0.93,
        shrink: 0.96,
      });
    }
  }

  draw() {
    // Draw smoke trail
    for (let i = 0; i < Math.min(10, this.trailParticles.length); i++) {
      const p = this.trailParticles[i];
      ctx.globalAlpha = p.life * 1.2;
      ctx.fillStyle = p.c;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Draw missile
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);

    // Missile body
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.roundRect(-6, -3, 12, 6, 2);
    ctx.fill();

    // Orange stripes
    ctx.fillStyle = this.color;
    ctx.fillRect(-4, -3, 8, 1);
    ctx.fillRect(-4, 2, 8, 1);

    // Nose cone
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(6, -3);
    ctx.lineTo(6, 3);
    ctx.lineTo(10, 0);
    ctx.closePath();
    ctx.fill();

    // Fins
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(-6, -3);
    ctx.lineTo(-8, -5);
    ctx.lineTo(-6, -1);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(-6, 3);
    ctx.lineTo(-8, 5);
    ctx.lineTo(-6, 1);
    ctx.closePath();
    ctx.fill();

    // Engine exhaust
    ctx.fillStyle = "#FF9800";
    ctx.beginPath();
    ctx.moveTo(-6, -2);
    ctx.lineTo(-8, 0);
    ctx.lineTo(-6, 2);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }
}

// Add roundRect polyfill if needed
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\path.js =====

import { TILE } from "./core.js";
import { lerp } from "./utils.js";
import { GRID_W, GRID_H, W as _W, H as _H } from "./core.js";
import { syncLogicalSize } from "./core.js";

// We'll compute path after canvas size sync. Export initPath to call from main.
export let path = [];
export let segLens = [];
export let totalLen = 0;
export const blocked = new Set();

export function initPath() {
  // Ensure canvas sizes are current
  // (main will call syncLogicalSize before this)
  const W = Math.max(
    1,
    Math.floor((document.querySelector("#game").clientWidth || 1100) / TILE) *
      TILE
  );
  const H = Math.max(
    1,
    Math.floor((document.querySelector("#game").clientHeight || 650) / TILE) *
      TILE
  );

  path = [
    { x: 0, y: H * 0.65 },
    { x: W * 0.18, y: H * 0.65 },
    { x: W * 0.18, y: H * 0.2 },
    { x: W * 0.45, y: H * 0.2 },
    { x: W * 0.45, y: H * 0.8 },
    { x: W * 0.72, y: H * 0.8 },
    { x: W * 0.72, y: H * 0.35 },
    { x: W * 0.98, y: H * 0.35 },
  ];

  segLens.length = 0;
  totalLen = 0;
  for (let i = 0; i < path.length - 1; i++) {
    const a = path[i],
      b = path[i + 1];
    const L = Math.hypot(b.x - a.x, b.y - a.y);
    segLens.push(L);
    totalLen += L;
  }

  blocked.clear();
  for (let i = 0; i < totalLen; i += TILE * 0.6) {
    const p = pointAt(i / totalLen);
    const gx = Math.floor(p.x / TILE),
      gy = Math.floor(p.y / TILE);
    blocked.add(`${gx},${gy}`);
  }
}

export function pointAt(t) {
  if (totalLen === 0) return { x: 0, y: 0 };
  let d = t * totalLen;
  for (let i = 0; i < segLens.length; i++) {
    if (d <= segLens[i]) {
      const a = path[i],
        b = path[i + 1];
      const r = d / segLens[i];
      return { x: lerp(a.x, b.x, r), y: lerp(a.y, b.y, r) };
    }
    d -= segLens[i];
  }
  return { ...path[path.length - 1] };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\spawner.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\spawner.js =====

import { enemies, state } from "./state.js";
import { Enemy, getEnemiesForWave } from "./enemy.js";
import { pulse } from "./utils.js";

let spawnTimer = 0;
let toSpawn = [];
let currentWaveEnemies = [];

export function startNextWave() {
  state.wave++;
  currentWaveEnemies = getEnemiesForWave(state.wave);
  toSpawn = [...currentWaveEnemies]; // Create a copy
  spawnTimer = 0;
  pulse(`Wave ${state.wave}!`, "#adf");
}

export function spawner(dt) {
  if (toSpawn.length === 0) {
    if (enemies.length === 0) startNextWave();
    return;
  }

  spawnTimer -= dt;
  if (spawnTimer <= 0) {
    const nextEnemy = toSpawn[0];
    enemies.push(new Enemy(nextEnemy.type, nextEnemy.tier));
    toSpawn.shift(); // Remove the first element

    // Adjust spawn timer based on wave difficulty
    spawnTimer = Math.max(0.25, 0.9 - state.wave * 0.03);
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\state.js =====

// Central mutable state (exported as objects so imported modules can mutate properties)
export const state = {
  money: 1000000,
  lives: 20,
  wave: 0,
  time: 0,
  running: true,
};

export const enemies = [];
export const towers = [];
export const projectiles = [];
export const particles = [];
export const beams = [];
export const circles = [];
export const pulses = [];

// UI selections
export const ui = {
  selectedShopKey: "gun",
  hoveredTile: null,
  selectedTower: null,
  shopScrollOffset: 0, // Add this line
  maxShopScroll: 0, // And this line
};


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\ui.js =====

import { ctx, TILE } from "./core.js";
import { roundRect, hit, clamp } from "./utils.js";
import { TOWER_TYPES } from "./config.js";
import { state, pulses, enemies, towers } from "./state.js";
import { ui } from "./state.js";
import { pointAt, blocked } from "./path.js";

export function drawBackground(t, pathArr) {
  ctx.fillStyle = "#0b0f1a";
  ctx.fillRect(
    0,
    0,
    Math.max(0, ctx.canvas.width),
    Math.max(0, ctx.canvas.height)
  );
  ctx.save();
  const W = ctx.canvas.clientWidth;
  const H = ctx.canvas.clientHeight;
  const g = ctx.createLinearGradient(0, 0, W, H);
  g.addColorStop(0, "rgba(0,180,255,0.05)");
  g.addColorStop(1, "rgba(255,0,220,0.05)");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);
  ctx.globalAlpha = 0.5;
  ctx.strokeStyle = "rgba(255,255,255,0.05)";
  ctx.lineWidth = 1;
  for (let x = 0; x <= W; x += TILE) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }
  for (let y = 0; y <= H; y += TILE) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
  ctx.restore();

  // Neon path
  if (pathArr && pathArr.length) {
    ctx.strokeStyle = "#29e3ff";
    ctx.lineWidth = 10;
    ctx.globalAlpha = 0.15;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(pathArr[0].x, pathArr[0].y);
    for (let i = 1; i < pathArr.length; i++)
      ctx.lineTo(pathArr[i].x, pathArr[i].y);
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#0cf";
    ctx.beginPath();
    ctx.moveTo(pathArr[0].x, pathArr[0].y);
    for (let i = 1; i < pathArr.length; i++)
      ctx.lineTo(pathArr[i].x, pathArr[i].y);
    ctx.stroke();
  }
}

export function drawTopbar(W) {
  roundRect(
    12,
    12,
    Math.max(200, W - 24),
    64,
    14,
    "rgba(10,20,36,0.85)",
    true,
    "rgba(42,72,116,0.8)"
  );
  ctx.font = "700 22px Inter, system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillStyle = "#bfe7ff";
  ctx.fillText(`Wave ${state.wave}`, 28, 52);
  ctx.fillStyle = "#e6ffb3";
  ctx.fillText(`$ ${state.money}`, 160, 52);
  ctx.fillStyle = state.lives > 5 ? "#b3ffd9" : "#ffc7c7";
  ctx.fillText(`❤ ${state.lives}`, 260, 52);

  for (const p of pulses) {
    p.y -= 20 / 60;
    p.life -= 1 / 60;
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.c;
    ctx.fillText(p.text, p.x || W - 120, p.y || 58);
    ctx.globalAlpha = 1;
  }
  for (let i = pulses.length - 1; i >= 0; i--)
    if (pulses[i].life <= 0) pulses.splice(i, 1);
}
export function getShopButtons(W, H) {
  const pad = 18;
  const y = H - 88;
  const h = 74;
  const w = 150;
  const keys = Object.keys(TOWER_TYPES);

  // Calculate total width needed
  const totalWidth = keys.length * (w + 12) - 12 + pad * 2;

  // Add scroll offset if needed
  const scrollOffset = ui.shopScrollOffset || 0;

  return keys.map((k, i) => ({
    key: k,
    x: pad + i * (w + 12) - scrollOffset,
    y,
    w,
    h,
  }));
}

export function drawShop(W, H) {
  const buttons = getShopButtons(W, H);
  const keys = Object.keys(TOWER_TYPES);

  // Calculate max scroll needed
  const totalWidth = keys.length * (150 + 12) - 12 + 18 * 2;
  ui.maxShopScroll = Math.max(0, totalWidth - W);

  // Draw scroll indicators if needed
  if (ui.maxShopScroll > 0) {
    // Left scroll indicator
    if (ui.shopScrollOffset > 0) {
      ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
      ctx.beginPath();
      ctx.moveTo(10, H - 40);
      ctx.lineTo(20, H - 50);
      ctx.lineTo(20, H - 30);
      ctx.closePath();
      ctx.fill();
    }

    // Right scroll indicator
    if (ui.shopScrollOffset < ui.maxShopScroll) {
      ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
      ctx.beginPath();
      ctx.moveTo(W - 10, H - 40);
      ctx.lineTo(W - 20, H - 50);
      ctx.lineTo(W - 20, H - 30);
      ctx.closePath();
      ctx.fill();
    }
  }

  // Clip the shop area to prevent buttons from drawing outside
  ctx.save();
  ctx.beginPath();
  ctx.rect(0, H - 100, W, 100);
  ctx.clip();

  for (const b of buttons) {
    const spec = TOWER_TYPES[b.key];
    const active = ui.selectedShopKey === b.key;
    const canAfford = state.money >= spec.cost;

    // Apply disabled styling if can't afford
    const bgColor = canAfford
      ? active
        ? "rgba(26,46,76,0.95)"
        : "rgba(12,22,36,0.9)"
      : "rgba(36,36,48,0.8)";

    const borderColor = canAfford
      ? active
        ? "#3d6fb6"
        : "#24496f"
      : "#444455";

    const textColor = canAfford ? spec.color : "#666677";
    const costColor = canAfford ? "#bfe7ff" : "#888899";

    roundRect(b.x, b.y, b.w, b.h, 12, bgColor, true, borderColor);

    ctx.fillStyle = textColor;
    ctx.font = "700 18px Inter, system-ui";
    ctx.fillText(spec.name, b.x + 16, b.y + 28);
    ctx.fillStyle = costColor;
    ctx.font = "500 14px Inter, system-ui";
    ctx.fillText(`$${spec.cost}  •  Rng ${spec.range}`, b.x + 16, b.y + 50);
  }

  ctx.restore(); // Restore clipping
}
export function drawGhost(
  hoveredTile,
  TILE,
  selectedShopKey,
  isDragging = false
) {
  if (!hoveredTile) return;

  const gx = hoveredTile.gx;
  const gy = hoveredTile.gy;
  const x = gx * TILE;
  const y = gy * TILE;

  // Check if placement is valid
  const valid =
    gx >= 0 &&
    gy >= 0 &&
    gy < Math.floor(ctx.canvas.clientHeight / TILE) - 2 &&
    !blocked.has(`${gx},${gy}`) &&
    !towers.some((t) => t.gx === gx && t.gy === gy);

  const spec = TOWER_TYPES[selectedShopKey];
  const c = { x: x + TILE / 2, y: y + TILE / 2 };

  // Draw range circle with higher opacity when dragging
  ctx.globalAlpha = isDragging ? 0.2 : 0.12;
  ctx.fillStyle = valid ? "#9f9" : "#f99";
  ctx.beginPath();
  ctx.arc(c.x, c.y, spec.range, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Draw ghost tower with higher opacity when dragging
  roundRect(
    x + 4,
    y + 4,
    TILE - 8,
    TILE - 8,
    10,
    valid
      ? isDragging
        ? "rgba(120,220,140,0.6)"
        : "rgba(120,220,140,0.35)"
      : isDragging
      ? "rgba(255,120,120,0.6)"
      : "rgba(255,120,120,0.35)"
  );
}

export function drawInspector(selectedTower) {
  if (!selectedTower) return;
  const t = selectedTower;
  const s = t.spec();
  const c = t.center;
  const panel = {
    x: clamp(c.x - 90, 12, ctx.canvas.clientWidth - 192),
    y: clamp(c.y - 110, 12, ctx.canvas.clientHeight - 210),
    w: 180,
    h: 120,
  };
  roundRect(
    panel.x,
    panel.y,
    panel.w,
    panel.h,
    12,
    "rgba(12,22,36,0.95)",
    true,
    "#2c527f"
  );
  ctx.fillStyle = "#bfe7ff";
  ctx.font = "700 16px Inter";
  ctx.fillText(`${s.name} Lv.${t.level}`, panel.x + 14, panel.y + 28);
  ctx.font = "500 14px Inter";
  ctx.fillText(
    `Dmg ${Math.round(s.dmg)}  Rng ${Math.round(s.range)}`,
    panel.x + 14,
    panel.y + 50
  );
  ctx.fillText(`Rate ${s.fireRate.toFixed(1)}/s`, panel.x + 14, panel.y + 70);
  ctx.fillText(`U: Upgrade $${t.upgradeCost()}`, panel.x + 14, panel.y + 92);
  ctx.fillText(
    `S: Sell $${Math.round(t.sellValue())}`,
    panel.x + 14,
    panel.y + 110
  );
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\utils.js =====

import { pulses } from "./state.js";
import { ctx } from "./core.js";

export const TAU = Math.PI * 2;
export const rand = (a = 1, b = 0) => Math.random() * (a - b) + b;
export const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
export const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
export const lerp = (a, b, t) => a + (b - a) * t;

export function roundRect(x, y, w, h, r, fillStyle, fill = true, strokeStyle) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) {
    ctx.fillStyle = fillStyle;
    ctx.fill();
  }
  if (strokeStyle) {
    ctx.strokeStyle = strokeStyle;
    ctx.stroke();
  }
}

export function hit(p, r) {
  return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
}

export function removeFromArray(arr, item) {
  const i = arr.indexOf(item);
  if (i >= 0) arr.splice(i, 1);
}

export function pulse(text, color = "#adf") {
  pulses.push({ text, x: 0, y: 0, life: 1.2, c: color });
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\BaseTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\BaseTower.js =====

import { ctx } from "../core.js";
import { dist } from "../utils.js";
import { spawnMuzzle } from "../effects.js";
import { projectiles } from "../state.js";
import { Bullet } from "../bullet.js";
import { roundRect } from "../helpers.js";

export class BaseTower {
  constructor(gx, gy, key) {
    this.gx = gx;
    this.gy = gy;
    this.key = key;
    this.level = 1;
    this.cool = 0;
    this.rot = 0;
  }

  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      bulletSpeed: base.bulletSpeed,
      splash: base.splash || 0,
      beam: base.beam || false,
      color: base.color,
      cost: base.cost,
    };
  }

  get center() {
    return { x: this.gx * 40 + 20, y: this.gy * 40 + 20 };
  }

  upgradeCost() {
    return Math.round(this.spec().cost * (0.75 + this.level * 0.75));
  }

  sellValue() {
    return this.spec().cost * 0.7 + (this.level - 1) * this.spec().cost * 0.35;
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;
    let best = null,
      bestScore = -1;

    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);
      if (d <= s.range && e.t > bestScore) {
        best = e;
        bestScore = e.t;
      }
    }

    if (!best) return;
    const c = this.center,
      bp = best.pos;
    this.rot = Math.atan2(bp.y - c.y, bp.x - c.x);

    if (s.beam) {
      const dps = s.dmg * 60;
      if (this.cool <= 0) {
        best.damage(dps * dt);
        this.fireBeam(c, bp, s.color);
      }
      return;
    }

    if (this.cool <= 0) {
      this.cool = 1 / s.fireRate;
      this.fireProjectile(c, best, s);
    }
  }

  fireProjectile(center, target, spec) {
    projectiles.push(new Bullet(center.x, center.y, target, spec));
    spawnMuzzle(center.x, center.y, this.rot, spec.color);
  }

  fireBeam(start, end, color) {
    // This will be implemented in the LaserTower class
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    roundRect(x - 16, y - 16, 32, 32, 8, "#0e1626", true, "#223c62");

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);
    ctx.fillStyle = s.color;

    // Default single barrel
    roundRect(-8, -8, 16, 16, 4, s.color, true);

    ctx.fillStyle = "#fff";
    ctx.fillRect(0, -3, 14, 6); // muzzle indicator
    ctx.restore();

    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.fillRect(x - 10 + i * 6, y + 18, 4, 4);
    }
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\CannonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\CannonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";

export class CannonTower extends BaseTower {
  static SPEC = {
    name: "Cannon",
    cost: 120,
    range: 140,
    fireRate: 1.2,
    dmg: 55,
    splash: 60,
    bulletSpeed: 260,
    color: "#f6c66a",
  };

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    // Draw base platform
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Draw platform border
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw cannon body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Cannon base
    ctx.fillStyle = "#3a3a4a";
    ctx.fillRect(-12, -8, 24, 16);

    // Cannon barrel - main body
    const gradient = ctx.createLinearGradient(0, -10, 0, 10);
    gradient.addColorStop(0, "#8a7a6a");
    gradient.addColorStop(0.5, "#b5a892");
    gradient.addColorStop(1, "#8a7a6a");
    ctx.fillStyle = gradient;

    // Draw barrel with rounded front
    ctx.beginPath();
    ctx.roundRect(-8, -6, 30, 12, 6);
    ctx.fill();

    // Barrel rings/bands
    ctx.fillStyle = "#5a5a6a";
    ctx.fillRect(-5, -7, 3, 14);
    ctx.fillRect(5, -7, 3, 14);
    ctx.fillRect(15, -7, 3, 14);

    // Cannon muzzle
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.arc(22, 0, 6, -Math.PI / 2, Math.PI / 2);
    ctx.fill();

    // Cannon interior (dark hole)
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(24, 0, 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Draw level indicators
    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(x - 10 + i * 6, y + 18, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\DoubleCannonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\DoubleCannonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { projectiles } from "../state.js";
import { spawnMuzzle } from "../effects.js";
import { Bullet } from "../bullet.js";
import { ctx } from "../core.js";

export class DoubleCannonTower extends BaseTower {
  static SPEC = {
    name: "Double Canon",
    cost: 160,
    range: 120,
    fireRate: 0.9,
    dmg: 75,
    splash: 55,
    bulletSpeed: 240,
    color: "#f00",
  };

  fireProjectile(center, target, spec) {
    const offset = 8; // Increased offset for wider barrels
    const sin = Math.sin(this.rot);
    const cos = Math.cos(this.rot);

    // left barrel
    projectiles.push(
      new Bullet(center.x - sin * offset, center.y + cos * offset, target, spec)
    );

    // right barrel
    projectiles.push(
      new Bullet(center.x + sin * offset, center.y - cos * offset, target, spec)
    );

    spawnMuzzle(
      center.x - sin * offset,
      center.y + cos * offset,
      this.rot,
      spec.color
    );
    spawnMuzzle(
      center.x + sin * offset,
      center.y - cos * offset,
      this.rot,
      spec.color
    );
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    // Draw base platform
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Draw platform border
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw cannon mounting platform
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Mounting base
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.roundRect(-14, -10, 28, 20, 6);
    ctx.fill();

    // Draw two cannon barrels
    const barrelOffset = 8;

    // Left cannon
    this.drawCannonBarrel(-barrelOffset, 0, s.color);

    // Right cannon
    this.drawCannonBarrel(barrelOffset, 0, s.color);

    // Central mounting hardware
    ctx.fillStyle = "#5a5a6a";
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    // Bolts on mounting platform
    ctx.fillStyle = "#7a7a8a";
    ctx.beginPath();
    ctx.arc(-10, -6, 2, 0, Math.PI * 2);
    ctx.arc(10, -6, 2, 0, Math.PI * 2);
    ctx.arc(-10, 6, 2, 0, Math.PI * 2);
    ctx.arc(10, 6, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Draw level indicators
    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(x - 12 + i * 6, y + 22, 3, 0, Math.PI * 2);
      ctx.fill();

      // Add glow effect for higher levels
      if (this.level > 2 && i >= this.level - 2) {
        ctx.fillStyle = "rgba(255, 100, 100, 0.4)";
        ctx.beginPath();
        ctx.arc(x - 12 + i * 6, y + 22, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  drawCannonBarrel(xOffset, yOffset, color) {
    // Cannon barrel - main body
    const gradient = ctx.createLinearGradient(xOffset - 5, -8, xOffset - 5, 8);
    gradient.addColorStop(0, "#9a8a7a");
    gradient.addColorStop(0.5, "#c5b8a2");
    gradient.addColorStop(1, "#9a8a7a");
    ctx.fillStyle = gradient;

    // Draw barrel with rounded front
    ctx.beginPath();
    ctx.roundRect(xOffset - 8, -5, 26, 10, 5);
    ctx.fill();

    // Barrel rings/bands
    ctx.fillStyle = "#6a6a7a";
    ctx.fillRect(xOffset - 5, -6, 3, 12);
    ctx.fillRect(xOffset + 5, -6, 3, 12);
    ctx.fillRect(xOffset + 15, -6, 3, 12);

    // Cannon muzzle
    ctx.fillStyle = "#5a5a6a";
    ctx.beginPath();
    ctx.arc(xOffset + 18, 0, 5, -Math.PI / 2, Math.PI / 2);
    ctx.fill();

    // Cannon interior (dark hole)
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(xOffset + 20, 0, 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Red accent on barrel (matching tower color)
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(xOffset - 2, 0, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\GunTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\GunTower.js =====

import { BaseTower } from "./BaseTower.js";

export class GunTower extends BaseTower {
  static SPEC = {
    name: "Gunner",
    cost: 80,
    range: 120,
    fireRate: 6,
    dmg: 12,
    bulletSpeed: 340,
    color: "#6cf",
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\IceTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\IceTower.js =====

import { BaseTower } from "./BaseTower.js";
import { projectiles } from "../state.js";
import { spawnMuzzle } from "../effects.js";
import { Bullet } from "../bullet.js";
import { ctx } from "../core.js";

export class IceTower extends BaseTower {
  static SPEC = {
    name: "Ice Tower",
    cost: 180,
    range: 130,
    fireRate: 2.5,
    dmg: 8,
    slowAmount: 0.6,
    slowDuration: 3,
    freezeChance: 0.2,
    bulletSpeed: 300,
    color: "#6cfaff",
  };

  // Override spec to include ice properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      slowAmount: base.slowAmount,
      slowDuration: base.slowDuration * (1 + (this.level - 1) * 0.1),
      freezeChance: base.freezeChance + (this.level - 1) * 0.05,
      bulletSpeed: base.bulletSpeed,
      color: base.color,
      cost: base.cost,
    };
  }

  fireProjectile(center, target, spec) {
    // Create ice projectile with special properties
    const iceBullet = new Bullet(center.x, center.y, target, spec);

    // Add ice-specific properties to the bullet
    iceBullet.isIce = true;
    iceBullet.slowAmount = spec.slowAmount;
    iceBullet.slowDuration = spec.slowDuration;
    iceBullet.freezeChance = spec.freezeChance;

    projectiles.push(iceBullet);
    spawnMuzzle(center.x, center.y, this.rot, spec.color);

    // Add frost particles effect
    this.spawnFrostParticles(center.x, center.y);
  }

  spawnFrostParticles(x, y) {
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 30 + Math.random() * 50;
      const size = 2 + Math.random() * 3;

      // Add to particles array (you might need to import it)
      const particles = window.particles || [];
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 0.5 + Math.random() * 0.3,
        r: size,
        c: "#a0f0ff",
        gravity: 0.2,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw icy base platform
    ctx.fillStyle = "#0e1a2a";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Icy glow effect
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 22);
    gradient.addColorStop(0, "rgba(108, 250, 255, 0.4)");
    gradient.addColorStop(1, "rgba(108, 250, 255, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Icy platform border
    ctx.strokeStyle = "#2a5a7a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw tower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main icy structure
    ctx.fillStyle = "#a0e0f0";
    ctx.beginPath();
    ctx.roundRect(-10, -10, 20, 20, 6);
    ctx.fill();

    // Ice crystal details
    ctx.fillStyle = "#d0f8ff";
    this.drawIceCrystal(-5, -5, 4, time);
    this.drawIceCrystal(5, -5, 3, time);
    this.drawIceCrystal(0, 5, 5, time);

    // Frost emitter (main crystal)
    const pulse = Math.sin(time * 3) * 1.5;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(12, 0, 4 + pulse, 0, Math.PI * 2);
    ctx.fill();

    // Inner crystal glow
    ctx.fillStyle = "rgba(176, 240, 255, 0.7)";
    ctx.beginPath();
    ctx.arc(12, 0, 2 + pulse * 0.5, 0, Math.PI * 2);
    ctx.fill();

    // Frost patterns on body
    ctx.strokeStyle = "rgba(200, 240, 255, 0.6)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-8, 2);
    ctx.lineTo(-2, -2);
    ctx.lineTo(2, 3);
    ctx.lineTo(6, -1);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as ice shards
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;

      // Glow effect
      ctx.fillStyle = "rgba(108, 250, 255, 0.3)";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 4, 0, Math.PI * 2);
      ctx.fill();

      // Ice shard
      ctx.fillStyle = s.color;
      this.drawIceShard(indicatorX, indicatorY, 3);

      // Frost effect for higher levels
      if (this.level > 2 && i >= this.level - 2) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Occasional snowflake particles
    if (Math.random() < 0.05) {
      this.drawSnowflake(x, y, time);
    }
  }

  drawIceCrystal(x, y, size, time) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(time);

    ctx.beginPath();
    ctx.moveTo(0, -size);
    ctx.lineTo(size * 0.7, 0);
    ctx.lineTo(0, size);
    ctx.lineTo(-size * 0.7, 0);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  drawIceShard(x, y, size) {
    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x + size * 0.7, y);
    ctx.lineTo(x, y + size);
    ctx.lineTo(x - size * 0.7, y);
    ctx.closePath();
    ctx.fill();
  }

  drawSnowflake(x, y, time) {
    const flakeX = x + (Math.random() - 0.5) * 30;
    const flakeY = y + (Math.random() - 0.5) * 30 - 20;
    const size = 1 + Math.random() * 2;

    ctx.save();
    ctx.translate(flakeX, flakeY);
    ctx.rotate(time);

    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
    ctx.lineWidth = 1;

    for (let i = 0; i < 6; i++) {
      ctx.rotate(Math.PI / 3);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(size * 2, 0);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(size * 0.7, -size * 0.7);
      ctx.lineTo(size * 0.7, size * 0.7);
      ctx.stroke();
    }

    ctx.restore();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\LaserTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\LaserTower.js =====

import { BaseTower } from "./BaseTower.js";
import { spawnBeam } from "../effects.js";
import { ctx } from "../core.js";

export class LaserTower extends BaseTower {
  static SPEC = {
    name: "Laser",
    cost: 250,
    range: 150,
    fireRate: 12,
    dmg: 5,
    beam: true,
    color: "#ff69e0",
  };

  fireBeam(start, end, color) {
    spawnBeam(start, end, color);
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw high-tech base platform with glow
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Platform glow effect
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 22);
    gradient.addColorStop(0, "rgba(255, 105, 224, 0.3)");
    gradient.addColorStop(1, "rgba(255, 105, 224, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with energy effect
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw tower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main housing - futuristic design
    ctx.fillStyle = "#2a2a3a";
    ctx.beginPath();
    ctx.roundRect(-10, -12, 20, 24, 8);
    ctx.fill();

    // Energy core housing
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fill();

    // Pulsing energy core
    const pulseSize = 6 + Math.sin(time * 5) * 1.5;
    const coreAlpha = 0.7 + Math.sin(time * 3) * 0.3;

    ctx.fillStyle = `rgba(255, 220, 255, ${coreAlpha})`;
    ctx.beginPath();
    ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "rgba(255, 105, 224, 0.6)";
    ctx.beginPath();
    ctx.arc(0, 0, pulseSize * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // Laser emitter array
    ctx.fillStyle = "#4a4a6a";
    ctx.beginPath();
    ctx.roundRect(8, -8, 16, 16, 4);
    ctx.fill();

    // Laser lenses
    ctx.fillStyle = "#a0a0ff";
    ctx.beginPath();
    ctx.arc(16, -4, 3, 0, Math.PI * 2);
    ctx.arc(16, 0, 3, 0, Math.PI * 2);
    ctx.arc(16, 4, 3, 0, Math.PI * 2);
    ctx.fill();

    // Main laser lens (center)
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(16, 0, 4, 0, Math.PI * 2);
    ctx.fill();

    // Energy conduits
    ctx.strokeStyle = "#ff69e0";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-6, -6);
    ctx.lineTo(6, -6);
    ctx.lineTo(10, -2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-6, 6);
    ctx.lineTo(6, 6);
    ctx.lineTo(10, 2);
    ctx.stroke();

    // Cooling fins/heat sinks
    ctx.fillStyle = "#3a3a5a";
    for (let i = -10; i <= 10; i += 5) {
      ctx.fillRect(-12, i, 4, 2);
    }

    ctx.restore();

    // Draw level indicators with glow effect
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;

      // Glow effect
      ctx.fillStyle = "rgba(255, 105, 224, 0.3)";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Main indicator
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Pulsing effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        const pulse = Math.sin(time * 4) * 2;
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, 3 + pulse, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Add some particle effects around the tower
    if (Math.random() < 0.1) {
      this.drawEnergyParticle(x, y, time);
    }
  }

  drawEnergyParticle(x, y, time) {
    const angle = Math.random() * Math.PI * 2;
    const distance = 15 + Math.random() * 10;
    const size = 1 + Math.random() * 2;

    const particleX = x + Math.cos(angle) * distance;
    const particleY = y + Math.sin(angle) * distance;

    ctx.fillStyle = `rgba(180, 100, 255, ${0.3 + Math.sin(time * 10) * 0.2})`;
    ctx.beginPath();
    ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\MissileTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\MissileTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, projectiles, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnExplosion, spawnMuzzle } from "../effects.js";
import { Missile } from "../missile.js"; // We'll create this special projectile

export class MissileTower extends BaseTower {
  static SPEC = {
    name: "Missile Tower",
    cost: 280,
    range: 160,
    fireRate: 0.8,
    dmg: 70,
    splash: 80,
    bulletSpeed: 180,
    homingStrength: 0.1,
    retarget: true,
    color: "#FF5722",
  };

  // Override spec to include missile properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.4; // Higher multiplier for damage
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.1), // Better range scaling
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      splash: base.splash * (1 + (this.level - 1) * 0.08),
      bulletSpeed: base.bulletSpeed,
      homingStrength: base.homingStrength + (this.level - 1) * 0.02,
      retarget: base.retarget,
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    // Always track enemies, not just when firing
    let best = null;
    let bestScore = -1;

    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);
      if (d <= s.range && e.t > bestScore) {
        best = e;
        bestScore = e.t;
      }
    }

    // Only rotate if there's a target
    if (best) {
      this.rot = Math.atan2(
        best.pos.y - this.center.y,
        best.pos.x - this.center.x
      );
    }

    // Fire if cooldown is ready and there's a target
    if (this.cool <= 0 && best) {
      this.cool = 1 / s.fireRate;
      this.fireMissile(best, s);
    }
  }

  fireMissile(target, spec) {
    const c = this.center;

    // Calculate missile start position (in front of the tower)
    const missileOffset = 20; // Distance in front of center
    const startX = c.x + Math.cos(this.rot) * missileOffset;
    const startY = c.y + Math.sin(this.rot) * missileOffset;

    // Create homing missile at the correct position
    const missile = new Missile(startX, startY, target, spec);
    missile.rotation = this.rot; // Set initial rotation
    projectiles.push(missile);

    // Muzzle flash and smoke at the launch position
    spawnMuzzle(startX, startY, this.rot, spec.color);
    this.spawnLaunchSmoke(startX, startY);

    // Tower recoil effect
    this.recoilEffect = 0.3;
  }

  spawnLaunchSmoke(x, y) {
    for (let i = 0; i < 12; i++) {
      const angle = this.rot + Math.PI + (Math.random() - 0.5) * 0.5;
      const speed = 60 + Math.random() * 60;
      const size = 3 + Math.random() * 3;
      const life = 1 + Math.random() * 0.5;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#888888",
        gravity: 0.1,
        fade: 0.92,
        shrink: 0.95,
      });
    }

    // Add some forward thrust particles too
    for (let i = 0; i < 6; i++) {
      const angle = this.rot + (Math.random() - 0.5) * 0.2;
      const speed = 100 + Math.random() * 100;
      const size = 2 + Math.random() * 2;
      const life = 0.5 + Math.random() * 0.3;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#FF5722",
        gravity: 0.05,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw missile base platform
    ctx.fillStyle = "#261a1a";
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Rocket launch pad glow
    const pulse = Math.sin(time * 4) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 28);
    gradient.addColorStop(0, `rgba(255, 87, 34, ${0.6 * pulse})`);
    gradient.addColorStop(1, "rgba(255, 87, 34, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 28, 0, Math.PI * 2);
    ctx.fill();

    // Platform border
    ctx.strokeStyle = "#4d2d2d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.stroke();

    // Draw missile launcher
    ctx.save();
    ctx.translate(x, y);

    // Apply recoil effect if recently fired
    if (this.recoilEffect > 0) {
      ctx.translate(0, this.recoilEffect * 2);
      this.recoilEffect -= 0.05;
    }

    ctx.rotate(this.rot);

    // Launcher base
    ctx.fillStyle = "#3d2d2d";
    ctx.beginPath();
    ctx.roundRect(-14, -10, 28, 20, 5);
    ctx.fill();

    // Launch rails
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-8, -15);
    ctx.lineTo(-8, 15);
    ctx.moveTo(8, -15);
    ctx.lineTo(8, 15);
    ctx.stroke();

    // Missile silo (if no recent fire)
    if (!this.recoilEffect || this.recoilEffect <= 0) {
      this.drawMissileInSilo();
    }

    // Targeting system
    ctx.fillStyle = "#2196F3";
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    // Targeting reticle
    ctx.strokeStyle = "#2196F3";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, Math.PI * 2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-8, 0);
    ctx.lineTo(8, 0);
    ctx.moveTo(0, -8);
    ctx.lineTo(0, 8);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as missile icons
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;

      // Missile icon
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.moveTo(indicatorX - 2, indicatorY - 4);
      ctx.lineTo(indicatorX + 2, indicatorY - 4);
      ctx.lineTo(indicatorX + 2, indicatorY + 4);
      ctx.lineTo(indicatorX - 2, indicatorY + 4);
      ctx.closePath();
      ctx.fill();

      // Missile tip
      ctx.beginPath();
      ctx.moveTo(indicatorX + 2, indicatorY);
      ctx.lineTo(indicatorX + 4, indicatorY);
      ctx.lineTo(indicatorX + 2, indicatorY - 2);
      ctx.closePath();
      ctx.fill();

      // Fire effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawMiniExhaust(indicatorX, indicatorY, time);
      }
    }

    // Random targeting laser effect
    if (Math.random() < 0.05) {
      this.drawTargetingLaser(x, y, time);
    }
  }

  drawMissileInSilo() {
    // Missile body - positioned to fire forward
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.roundRect(-4, -24, 8, 24, 3); // Moved forward (negative Y)
    ctx.fill();

    // Missile stripes
    ctx.fillStyle = "#FF5722";
    ctx.fillRect(-4, -16, 8, 3); // Adjusted positions
    ctx.fillRect(-4, -9, 8, 3); // Adjusted positions

    // Missile nose cone - pointing forward
    ctx.fillStyle = "#FF5722";
    ctx.beginPath();
    ctx.moveTo(-4, -24);
    ctx.lineTo(4, -24);
    ctx.lineTo(0, -30); // Pointing forward (negative Y)
    ctx.closePath();
    ctx.fill();

    // Fins - adjusted position
    ctx.fillStyle = "#FF5722";
    ctx.beginPath();
    ctx.moveTo(-4, -2); // Adjusted position
    ctx.lineTo(-8, -2); // Adjusted position
    ctx.lineTo(-4, 2); // Adjusted position
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(4, -2); // Adjusted position
    ctx.lineTo(8, -2); // Adjusted position
    ctx.lineTo(4, 2); // Adjusted position
    ctx.closePath();
    ctx.fill();
  }

  drawMiniExhaust(x, y, time) {
    const pulse = Math.sin(time * 8) * 0.5 + 1;

    ctx.fillStyle = `rgba(255, 87, 34, ${0.8 * pulse})`;
    ctx.beginPath();
    ctx.arc(x - 4, y, 2 * pulse, 0, Math.PI * 2);
    ctx.fill();
  }

  drawTargetingLaser(x, y, time) {
    const angle = this.rot + (Math.random() - 0.5) * 0.2;
    const length = 30 + Math.random() * 20;

    ctx.strokeStyle = `rgba(33, 150, 243, ${0.6 + Math.sin(time * 10) * 0.4})`;
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 2]);
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\PoisonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\PoisonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnPoisonCloud } from "../effects.js";

export class PoisonTower extends BaseTower {
  static SPEC = {
    name: "Poison Tower",
    cost: 190,
    range: 110,
    fireRate: 1.5,
    dmg: 15,
    dotDamage: 8,
    dotDuration: 4,
    spreadRange: 60,
    cloudDuration: 3,
    color: "#4CAF50",
  };

  // Override spec to include poison properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      dotDamage: base.dotDamage * mult,
      dotDuration: base.dotDuration * (1 + (this.level - 1) * 0.1),
      spreadRange: base.spreadRange * (1 + (this.level - 1) * 0.05),
      cloudDuration: base.cloudDuration * (1 + (this.level - 1) * 0.1),
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    if (this.cool <= 0) {
      let best = null;
      let bestScore = -1;

      for (const e of enemiesList) {
        if (e.dead || e.poisoned) continue; // Don't target already poisoned enemies
        const p = e.pos;
        const d = dist(this.center, p);
        if (d <= s.range && e.t > bestScore) {
          best = e;
          bestScore = e.t;
        }
      }

      if (best) {
        this.cool = 1 / s.fireRate;
        this.rot = Math.atan2(
          best.pos.y - this.center.y,
          best.pos.x - this.center.x
        );
        this.firePoison(best, s);
      }
    }
  }

  firePoison(target, spec) {
    const c = this.center;

    // Initial damage
    target.damage(spec.dmg);

    // Apply poison effect
    this.applyPoisonEffect(target, spec);

    // Create poison cloud at target location
    spawnPoisonCloud(
      target.pos.x,
      target.pos.y,
      spec.cloudDuration,
      spec.spreadRange
    );

    // Visual effects
    this.spawnPoisonParticles(c.x, c.y, target.pos.x, target.pos.y);
    this.spawnDrippingEffect(c.x, c.y);
  }

  applyPoisonEffect(enemy, spec) {
    if (enemy.poisoned) return; // Already poisoned

    enemy.poisoned = true;
    enemy.poisonDamage = spec.dotDamage;
    enemy.poisonDuration = spec.dotDuration;
    enemy.poisonStartTime = performance.now();

    // Start poison damage tick
    const poisonInterval = setInterval(() => {
      if (enemy.dead || !enemy.poisoned) {
        clearInterval(poisonInterval);
        return;
      }

      const elapsed = (performance.now() - enemy.poisonStartTime) / 1000;
      if (elapsed >= enemy.poisonDuration) {
        enemy.poisoned = false;
        clearInterval(poisonInterval);
        return;
      }

      // Apply damage
      enemy.damage(enemy.poisonDamage / 4); // Damage 4 times per second

      // Chance to spread to nearby enemies
      if (Math.random() < 0.2) {
        // 20% chance per tick to spread
        this.spreadPoison(enemy, spec);
      }
    }, 250); // Tick 4 times per second
  }

  spreadPoison(sourceEnemy, spec) {
    for (const e of enemies) {
      if (e.dead || e.poisoned || e === sourceEnemy) continue;

      const d = dist(sourceEnemy.pos, e.pos);
      if (d <= spec.spreadRange) {
        this.applyPoisonEffect(e, spec);
        spawnPoisonCloud(
          e.pos.x,
          e.pos.y,
          spec.cloudDuration / 2,
          spec.spreadRange / 2
        );
        break; // Only spread to one enemy at a time
      }
    }
  }

  spawnPoisonParticles(startX, startY, endX, endY) {
    for (let i = 0; i < 6; i++) {
      const angle = Math.atan2(endY - startY, endX - startX);
      const spread = (Math.random() - 0.5) * 0.5;
      const speed = 120 + Math.random() * 80;
      const size = 2 + Math.random() * 2;
      const life = 0.8 + Math.random() * 0.4;

      particles.push({
        x: startX,
        y: startY,
        vx: Math.cos(angle + spread) * speed,
        vy: Math.sin(angle + spread) * speed,
        life,
        r: size,
        c: "#4CAF50",
        gravity: 0.3,
        fade: 0.9,
      });
    }
  }

  spawnDrippingEffect(x, y) {
    // Create dripping poison effect from tower
    for (let i = 0; i < 3; i++) {
      const angle = Math.random() * Math.PI - Math.PI / 2; // Mostly downward
      const speed = 40 + Math.random() * 30;
      const size = 1.5 + Math.random() * 1.5;
      const life = 1 + Math.random() * 0.5;

      particles.push({
        x: x + (Math.random() - 0.5) * 10,
        y: y + 15,
        vx: Math.cos(angle) * speed * 0.3,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#388E3C",
        gravity: 0.5,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw toxic base platform
    ctx.fillStyle = "#1a261a";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Toxic glow effect
    const pulse = Math.sin(time * 3) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 10, x, y, 25);
    gradient.addColorStop(0, `rgba(76, 175, 80, ${0.5 * pulse})`);
    gradient.addColorStop(1, "rgba(76, 175, 80, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with toxic effect
    ctx.strokeStyle = "#2d4d2d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw toxic container body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main toxic container
    ctx.fillStyle = "#2d4d2d";
    ctx.beginPath();
    ctx.roundRect(-12, -12, 24, 24, 6);
    ctx.fill();

    // Toxic liquid level (animated)
    const liquidLevel = 0.6 + Math.sin(time * 2) * 0.1;
    ctx.fillStyle = "#4CAF50";
    ctx.beginPath();
    ctx.roundRect(-10, 10 - liquidLevel * 20, 20, liquidLevel * 20, 4);
    ctx.fill();

    // Container details
    ctx.strokeStyle = "#388E3C";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-12, -12, 24, 24, 6);
    ctx.stroke();

    // Toxic emitter nozzle
    ctx.fillStyle = "#3d6d3d";
    ctx.beginPath();
    ctx.roundRect(8, -6, 12, 12, 3);
    ctx.fill();

    // Nozzle opening
    ctx.fillStyle = "#1a261a";
    ctx.beginPath();
    ctx.roundRect(16, -4, 4, 8, 1);
    ctx.fill();

    // Bubbles in toxic liquid
    ctx.fillStyle = "#A5D6A7";
    for (let i = 0; i < 3; i++) {
      const bubbleX = -8 + Math.random() * 16;
      const bubbleY = -5 + Math.random() * 10;
      const bubbleSize = 1 + Math.random() * 2;
      const bubblePulse = Math.sin(time * 3 + i) * 0.3 + 1;

      ctx.beginPath();
      ctx.arc(bubbleX, bubbleY, bubbleSize * bubblePulse, 0, Math.PI * 2);
      ctx.fill();
    }

    // Hazard symbols
    ctx.strokeStyle = "#FFEB3B";
    ctx.lineWidth = 2;
    ctx.beginPath();
    // Skull shape
    ctx.arc(0, -5, 4, 0, Math.PI * 2);
    ctx.moveTo(-3, 0);
    ctx.lineTo(3, 0);
    ctx.moveTo(-4, 2);
    ctx.lineTo(4, 2);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as toxic bubbles
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;
      const bubblePulse = Math.sin(time * 4 + i) * 0.5 + 1;

      // Bubble glow
      ctx.fillStyle = `rgba(76, 175, 80, ${0.4 * bubblePulse})`;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5 * bubblePulse, 0, Math.PI * 2);
      ctx.fill();

      // Main bubble
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Bubble highlight
      ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
      ctx.beginPath();
      ctx.arc(indicatorX - 1, indicatorY - 1, 1, 0, Math.PI * 2);
      ctx.fill();
    }

    // Occasional toxic bubbles rising from tower
    if (Math.random() < 0.1) {
      this.drawRisingBubble(x, y, time);
    }

    // Toxic dripping from nozzle
    if (Math.random() < 0.3) {
      this.drawToxicDrip(x, y, time);
    }
  }

  drawRisingBubble(x, y, time) {
    const bubbleX = x + (Math.random() - 0.5) * 15;
    const bubbleY = y - 20 - Math.random() * 10;
    const size = 1.5 + Math.random() * 1.5;

    ctx.fillStyle = "rgba(165, 214, 167, 0.8)";
    ctx.beginPath();
    ctx.arc(bubbleX, bubbleY, size, 0, Math.PI * 2);
    ctx.fill();

    // Bubble highlight
    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
    ctx.beginPath();
    ctx.arc(
      bubbleX - size * 0.3,
      bubbleY - size * 0.3,
      size * 0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  drawToxicDrip(x, y, time) {
    const dripX = x + 18 + (Math.random() - 0.5) * 2;
    const dripLength = 3 + Math.random() * 4;

    ctx.strokeStyle = "#388E3C";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(dripX, y - 5);
    ctx.lineTo(dripX, y - 5 - dripLength);
    ctx.stroke();

    // Drip end
    ctx.fillStyle = "#388E3C";
    ctx.beginPath();
    ctx.arc(dripX, y - 5 - dripLength, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\TeslaTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\TeslaTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies } from "../state.js";
import { spawnLightningArc, spawnElectricExplosion } from "../effects.js";
import { particles } from "../state.js";
import { dist } from "../utils.js";

export class TeslaTower extends BaseTower {
  static SPEC = {
    name: "Tesla Tower",
    cost: 300,
    range: 140,
    fireRate: 1.3,
    dmg: 25,
    chainCount: 3,
    chainRange: 80,
    stunChance: 0.3,
    stunDuration: 1.5,
    color: "#9d4edd",
  };

  // Override spec to include tesla properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      chainCount: base.chainCount + Math.floor(this.level / 2), // +1 chain every 2 levels
      chainRange: base.chainRange * (1 + (this.level - 1) * 0.05),
      stunChance: base.stunChance + (this.level - 1) * 0.05,
      stunDuration: base.stunDuration * (1 + (this.level - 1) * 0.1),
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    if (this.cool <= 0) {
      let best = null;
      let bestScore = -1;

      for (const e of enemiesList) {
        if (e.dead) continue;
        const p = e.pos;
        const d = dist(this.center, p);
        if (d <= s.range && e.t > bestScore) {
          best = e;
          bestScore = e.t;
        }
      }

      if (best) {
        this.cool = 1 / s.fireRate;
        this.rot = Math.atan2(
          best.pos.y - this.center.y,
          best.pos.x - this.center.x
        );
        this.fireLightning(best, s);
      }
    }
  }

  fireLightning(primaryTarget, spec) {
    const c = this.center;
    const hitEnemies = new Set([primaryTarget]);

    // Damage primary target
    primaryTarget.damage(spec.dmg);
    this.applyStun(primaryTarget, spec);

    // Create primary lightning arc
    spawnLightningArc(c, primaryTarget.pos, spec.color);
    spawnElectricExplosion(primaryTarget.pos.x, primaryTarget.pos.y);

    // Chain to additional targets
    let currentTarget = primaryTarget;
    for (let i = 0; i < spec.chainCount; i++) {
      const nextTarget = this.findNextChainTarget(
        currentTarget,
        hitEnemies,
        spec.chainRange
      );
      if (!nextTarget) break;

      // Damage chained target (reduced damage)
      const chainDmg = spec.dmg * (0.6 - i * 0.1); // 60%, 50%, 40%, etc.
      nextTarget.damage(chainDmg);
      this.applyStun(nextTarget, spec);

      // Create chain lightning arc
      spawnLightningArc(currentTarget.pos, nextTarget.pos, spec.color);
      spawnElectricExplosion(nextTarget.pos.x, nextTarget.pos.y);

      hitEnemies.add(nextTarget);
      currentTarget = nextTarget;
    }

    // Visual effects on the tower itself
    this.spawnElectricParticles(c.x, c.y);
  }

  findNextChainTarget(currentTarget, hitEnemies, chainRange) {
    let bestTarget = null;
    let bestDistance = Infinity;

    for (const e of enemies) {
      if (e.dead || hitEnemies.has(e)) continue;

      const d = dist(currentTarget.pos, e.pos);
      if (d <= chainRange && d < bestDistance) {
        bestTarget = e;
        bestDistance = d;
      }
    }

    return bestTarget;
  }

  applyStun(enemy, spec) {
    if (Math.random() < spec.stunChance && !enemy.stunned) {
      enemy.stunned = true;
      enemy.originalSpeed = enemy.speed;
      enemy.speed = 0;

      // Set timeout to remove stun
      setTimeout(() => {
        if (!enemy.dead) {
          enemy.stunned = false;
          enemy.speed = enemy.originalSpeed;
          enemy.electricEffect = false;
        }
      }, spec.stunDuration * 1000);

      enemy.electricEffect = true;
      enemy.electricEffectTime = spec.stunDuration;
    }
  }

  spawnElectricParticles(x, y) {
    for (let i = 0; i < 8; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 50 + Math.random() * 100;
      const size = 1 + Math.random() * 2;
      const life = 0.3 + Math.random() * 0.2;

      // Use the imported particles array instead of window.particles
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#e0aaff",
        gravity: 0.1,
        fade: 0.9,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw electrified base platform
    ctx.fillStyle = "#1a1426";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Electric glow effect
    const pulse = Math.sin(time * 5) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 10, x, y, 25);
    gradient.addColorStop(0, `rgba(157, 78, 221, ${0.6 * pulse})`);
    gradient.addColorStop(1, "rgba(157, 78, 221, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with electric effect
    ctx.strokeStyle = "#5a2d91";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw Tesla coil body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main coil base
    ctx.fillStyle = "#2a1a3a";
    ctx.beginPath();
    ctx.roundRect(-12, -14, 24, 28, 8);
    ctx.fill();

    // Tesla coil primary
    ctx.fillStyle = "#3a2a4a";
    ctx.beginPath();
    ctx.roundRect(-8, -16, 16, 32, 6);
    ctx.fill();

    // Coil windings
    ctx.strokeStyle = "#7d5ba6";
    ctx.lineWidth = 2;
    for (let i = -12; i <= 12; i += 4) {
      ctx.beginPath();
      ctx.arc(0, i, 6, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Top electrode (Tesla ball)
    ctx.fillStyle = "#e0aaff";
    ctx.beginPath();
    ctx.arc(0, -20, 6, 0, Math.PI * 2);
    ctx.fill();

    // Electric arc effect from top electrode
    const arcPulse = Math.sin(time * 10) * 2;
    ctx.strokeStyle = `rgba(224, 170, 255, ${0.7 + Math.sin(time * 15) * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, -26);
    for (let i = 0; i < 3; i++) {
      const offsetX = (Math.random() - 0.5) * 8;
      const offsetY = -30 - i * 4 + (Math.random() - 0.5) * 3;
      ctx.lineTo(offsetX, offsetY);
    }
    ctx.stroke();

    // Secondary coils
    ctx.fillStyle = "#4a3a5a";
    ctx.beginPath();
    ctx.roundRect(10, -10, 6, 20, 2);
    ctx.fill();

    ctx.beginPath();
    ctx.roundRect(-16, -10, 6, 20, 2);
    ctx.fill();

    // Energy conduits
    ctx.strokeStyle = "#9d4edd";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-8, 12);
    ctx.lineTo(-12, 16);
    ctx.moveTo(8, 12);
    ctx.lineTo(12, 16);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as electric orbs
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;
      const orbPulse = Math.sin(time * 4 + i) * 0.5 + 1;

      // Energy glow
      ctx.fillStyle = `rgba(157, 78, 221, ${0.4 * orbPulse})`;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5 * orbPulse, 0, Math.PI * 2);
      ctx.fill();

      // Main orb
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Electric spark effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawElectricSpark(indicatorX, indicatorY, time);
      }
    }

    // Random electric arcs between tower parts
    if (Math.random() < 0.1) {
      this.drawRandomArc(x, y, time);
    }
  }

  drawElectricSpark(x, y, time) {
    const angle = Math.random() * Math.PI * 2;
    const length = 5 + Math.random() * 8;

    ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 + Math.sin(time * 20) * 0.2})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y);

    for (let i = 0; i < 3; i++) {
      const segX = x + (Math.cos(angle) * length * (i + 1)) / 3;
      const segY = y + (Math.sin(angle) * length * (i + 1)) / 3;
      const offsetX = (Math.random() - 0.5) * 3;
      const offsetY = (Math.random() - 0.5) * 3;
      ctx.lineTo(segX + offsetX, segY + offsetY);
    }

    ctx.stroke();
  }

  drawRandomArc(x, y, time) {
    const startAngle = Math.random() * Math.PI * 2;
    const endAngle = startAngle + (Math.random() - 0.5) * Math.PI;
    const startDist = 15 + Math.random() * 10;
    const endDist = 5 + Math.random() * 8;

    const startX = x + Math.cos(startAngle) * startDist;
    const startY = y + Math.sin(startAngle) * startDist;
    const endX = x + Math.cos(endAngle) * endDist;
    const endY = y + Math.sin(endAngle) * endDist;

    ctx.strokeStyle = `rgba(224, 170, 255, ${0.7 + Math.sin(time * 20) * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(startX, startY);

    // Create jagged lightning effect
    const segments = 5;
    const dx = (endX - startX) / segments;
    const dy = (endY - startY) / segments;

    for (let i = 1; i <= segments; i++) {
      const segX = startX + dx * i;
      const segY = startY + dy * i;
      const offsetX = (Math.random() - 0.5) * 8;
      const offsetY = (Math.random() - 0.5) * 8;
      ctx.lineTo(segX + offsetX, segY + offsetY);
    }

    ctx.stroke();
  }
}
