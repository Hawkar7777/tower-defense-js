

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\BaseTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\BaseTower.js =====

import { ctx } from "../core.js";
import { dist } from "../utils.js";
import { spawnMuzzle } from "../effects.js";
import { projectiles } from "../state.js";
import { Bullet } from "../bullet.js";
import { roundRect } from "../helpers.js";

export class BaseTower {
  constructor(gx, gy, key) {
    this.gx = gx;
    this.gy = gy;
    this.key = key;
    this.level = 1;
    this.cool = 0;
    this.rot = 0;
  }

  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      bulletSpeed: base.bulletSpeed,
      splash: base.splash || 0,
      beam: base.beam || false,
      color: base.color,
      cost: base.cost,
    };
  }

  get center() {
    return { x: this.gx * 40 + 20, y: this.gy * 40 + 20 };
  }

  upgradeCost() {
    return Math.round(this.spec().cost * (0.75 + this.level * 0.75));
  }

  sellValue() {
    return this.spec().cost * 0.7 + (this.level - 1) * this.spec().cost * 0.35;
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;
    let best = null,
      bestScore = -1;

    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);
      if (d <= s.range && e.t > bestScore) {
        best = e;
        bestScore = e.t;
      }
    }

    if (!best) return;
    const c = this.center,
      bp = best.pos;
    this.rot = Math.atan2(bp.y - c.y, bp.x - c.x);

    if (s.beam) {
      const dps = s.dmg * 60;
      if (this.cool <= 0) {
        best.damage(dps * dt);
        this.fireBeam(c, bp, s.color);
      }
      return;
    }

    if (this.cool <= 0) {
      this.cool = 1 / s.fireRate;
      this.fireProjectile(c, best, s);
    }
  }

  fireProjectile(center, target, spec) {
    projectiles.push(new Bullet(center.x, center.y, target, spec));
    spawnMuzzle(center.x, center.y, this.rot, spec.color);
  }

  fireBeam(start, end, color) {
    // This will be implemented in the LaserTower class
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    roundRect(x - 16, y - 16, 32, 32, 8, "#0e1626", true, "#223c62");

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);
    ctx.fillStyle = s.color;

    // Default single barrel
    roundRect(-8, -8, 16, 16, 4, s.color, true);

    ctx.fillStyle = "#fff";
    ctx.fillRect(0, -3, 14, 6); // muzzle indicator
    ctx.restore();

    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.fillRect(x - 10 + i * 6, y + 18, 4, 4);
    }
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\CannonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\CannonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";

export class CannonTower extends BaseTower {
  static SPEC = {
    name: "Cannon",
    cost: 120,
    range: 140,
    fireRate: 1.2,
    dmg: 55,
    splash: 60,
    bulletSpeed: 260,
    color: "#f6c66a",
  };

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    // Draw base platform
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Draw platform border
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw cannon body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Cannon base
    ctx.fillStyle = "#3a3a4a";
    ctx.fillRect(-12, -8, 24, 16);

    // Cannon barrel - main body
    const gradient = ctx.createLinearGradient(0, -10, 0, 10);
    gradient.addColorStop(0, "#8a7a6a");
    gradient.addColorStop(0.5, "#b5a892");
    gradient.addColorStop(1, "#8a7a6a");
    ctx.fillStyle = gradient;

    // Draw barrel with rounded front
    ctx.beginPath();
    ctx.roundRect(-8, -6, 30, 12, 6);
    ctx.fill();

    // Barrel rings/bands
    ctx.fillStyle = "#5a5a6a";
    ctx.fillRect(-5, -7, 3, 14);
    ctx.fillRect(5, -7, 3, 14);
    ctx.fillRect(15, -7, 3, 14);

    // Cannon muzzle
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.arc(22, 0, 6, -Math.PI / 2, Math.PI / 2);
    ctx.fill();

    // Cannon interior (dark hole)
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(24, 0, 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Draw level indicators
    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(x - 10 + i * 6, y + 18, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\DoubleCannonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\DoubleCannonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { projectiles } from "../state.js";
import { spawnMuzzle } from "../effects.js";
import { Bullet } from "../bullet.js";
import { ctx } from "../core.js";

export class DoubleCannonTower extends BaseTower {
  static SPEC = {
    name: "Double Canon",
    cost: 160,
    range: 120,
    fireRate: 0.9,
    dmg: 75,
    splash: 55,
    bulletSpeed: 240,
    color: "#f00",
  };

  fireProjectile(center, target, spec) {
    const offset = 8; // Increased offset for wider barrels
    const sin = Math.sin(this.rot);
    const cos = Math.cos(this.rot);

    // left barrel
    projectiles.push(
      new Bullet(center.x - sin * offset, center.y + cos * offset, target, spec)
    );

    // right barrel
    projectiles.push(
      new Bullet(center.x + sin * offset, center.y - cos * offset, target, spec)
    );

    spawnMuzzle(
      center.x - sin * offset,
      center.y + cos * offset,
      this.rot,
      spec.color
    );
    spawnMuzzle(
      center.x + sin * offset,
      center.y - cos * offset,
      this.rot,
      spec.color
    );
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    // Draw base platform
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Draw platform border
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw cannon mounting platform
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Mounting base
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.roundRect(-14, -10, 28, 20, 6);
    ctx.fill();

    // Draw two cannon barrels
    const barrelOffset = 8;

    // Left cannon
    this.drawCannonBarrel(-barrelOffset, 0, s.color);

    // Right cannon
    this.drawCannonBarrel(barrelOffset, 0, s.color);

    // Central mounting hardware
    ctx.fillStyle = "#5a5a6a";
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    // Bolts on mounting platform
    ctx.fillStyle = "#7a7a8a";
    ctx.beginPath();
    ctx.arc(-10, -6, 2, 0, Math.PI * 2);
    ctx.arc(10, -6, 2, 0, Math.PI * 2);
    ctx.arc(-10, 6, 2, 0, Math.PI * 2);
    ctx.arc(10, 6, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Draw level indicators
    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(x - 12 + i * 6, y + 22, 3, 0, Math.PI * 2);
      ctx.fill();

      // Add glow effect for higher levels
      if (this.level > 2 && i >= this.level - 2) {
        ctx.fillStyle = "rgba(255, 100, 100, 0.4)";
        ctx.beginPath();
        ctx.arc(x - 12 + i * 6, y + 22, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  drawCannonBarrel(xOffset, yOffset, color) {
    // Cannon barrel - main body
    const gradient = ctx.createLinearGradient(xOffset - 5, -8, xOffset - 5, 8);
    gradient.addColorStop(0, "#9a8a7a");
    gradient.addColorStop(0.5, "#c5b8a2");
    gradient.addColorStop(1, "#9a8a7a");
    ctx.fillStyle = gradient;

    // Draw barrel with rounded front
    ctx.beginPath();
    ctx.roundRect(xOffset - 8, -5, 26, 10, 5);
    ctx.fill();

    // Barrel rings/bands
    ctx.fillStyle = "#6a6a7a";
    ctx.fillRect(xOffset - 5, -6, 3, 12);
    ctx.fillRect(xOffset + 5, -6, 3, 12);
    ctx.fillRect(xOffset + 15, -6, 3, 12);

    // Cannon muzzle
    ctx.fillStyle = "#5a5a6a";
    ctx.beginPath();
    ctx.arc(xOffset + 18, 0, 5, -Math.PI / 2, Math.PI / 2);
    ctx.fill();

    // Cannon interior (dark hole)
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(xOffset + 20, 0, 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Red accent on barrel (matching tower color)
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(xOffset - 2, 0, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\GunTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\GunTower.js =====

import { BaseTower } from "./BaseTower.js";

export class GunTower extends BaseTower {
  static SPEC = {
    name: "Gunner",
    cost: 80,
    range: 120,
    fireRate: 6,
    dmg: 12,
    bulletSpeed: 340,
    color: "#6cf",
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\IceTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\IceTower.js =====

import { BaseTower } from "./BaseTower.js";
import { projectiles } from "../state.js";
import { spawnMuzzle } from "../effects.js";
import { Bullet } from "../bullet.js";
import { ctx } from "../core.js";

export class IceTower extends BaseTower {
  static SPEC = {
    name: "Ice Tower",
    cost: 180,
    range: 130,
    fireRate: 2.5,
    dmg: 8,
    slowAmount: 0.6,
    slowDuration: 3,
    freezeChance: 0.2,
    bulletSpeed: 300,
    color: "#6cfaff",
  };

  // Override spec to include ice properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      slowAmount: base.slowAmount,
      slowDuration: base.slowDuration * (1 + (this.level - 1) * 0.1),
      freezeChance: base.freezeChance + (this.level - 1) * 0.05,
      bulletSpeed: base.bulletSpeed,
      color: base.color,
      cost: base.cost,
    };
  }

  fireProjectile(center, target, spec) {
    // Create ice projectile with special properties
    const iceBullet = new Bullet(center.x, center.y, target, spec);

    // Add ice-specific properties to the bullet
    iceBullet.isIce = true;
    iceBullet.slowAmount = spec.slowAmount;
    iceBullet.slowDuration = spec.slowDuration;
    iceBullet.freezeChance = spec.freezeChance;

    projectiles.push(iceBullet);
    spawnMuzzle(center.x, center.y, this.rot, spec.color);

    // Add frost particles effect
    this.spawnFrostParticles(center.x, center.y);
  }

  spawnFrostParticles(x, y) {
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 30 + Math.random() * 50;
      const size = 2 + Math.random() * 3;

      // Add to particles array (you might need to import it)
      const particles = window.particles || [];
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 0.5 + Math.random() * 0.3,
        r: size,
        c: "#a0f0ff",
        gravity: 0.2,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw icy base platform
    ctx.fillStyle = "#0e1a2a";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Icy glow effect
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 22);
    gradient.addColorStop(0, "rgba(108, 250, 255, 0.4)");
    gradient.addColorStop(1, "rgba(108, 250, 255, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Icy platform border
    ctx.strokeStyle = "#2a5a7a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw tower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main icy structure
    ctx.fillStyle = "#a0e0f0";
    ctx.beginPath();
    ctx.roundRect(-10, -10, 20, 20, 6);
    ctx.fill();

    // Ice crystal details
    ctx.fillStyle = "#d0f8ff";
    this.drawIceCrystal(-5, -5, 4, time);
    this.drawIceCrystal(5, -5, 3, time);
    this.drawIceCrystal(0, 5, 5, time);

    // Frost emitter (main crystal)
    const pulse = Math.sin(time * 3) * 1.5;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(12, 0, 4 + pulse, 0, Math.PI * 2);
    ctx.fill();

    // Inner crystal glow
    ctx.fillStyle = "rgba(176, 240, 255, 0.7)";
    ctx.beginPath();
    ctx.arc(12, 0, 2 + pulse * 0.5, 0, Math.PI * 2);
    ctx.fill();

    // Frost patterns on body
    ctx.strokeStyle = "rgba(200, 240, 255, 0.6)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-8, 2);
    ctx.lineTo(-2, -2);
    ctx.lineTo(2, 3);
    ctx.lineTo(6, -1);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as ice shards
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;

      // Glow effect
      ctx.fillStyle = "rgba(108, 250, 255, 0.3)";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 4, 0, Math.PI * 2);
      ctx.fill();

      // Ice shard
      ctx.fillStyle = s.color;
      this.drawIceShard(indicatorX, indicatorY, 3);

      // Frost effect for higher levels
      if (this.level > 2 && i >= this.level - 2) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Occasional snowflake particles
    if (Math.random() < 0.05) {
      this.drawSnowflake(x, y, time);
    }
  }

  drawIceCrystal(x, y, size, time) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(time);

    ctx.beginPath();
    ctx.moveTo(0, -size);
    ctx.lineTo(size * 0.7, 0);
    ctx.lineTo(0, size);
    ctx.lineTo(-size * 0.7, 0);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  drawIceShard(x, y, size) {
    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x + size * 0.7, y);
    ctx.lineTo(x, y + size);
    ctx.lineTo(x - size * 0.7, y);
    ctx.closePath();
    ctx.fill();
  }

  drawSnowflake(x, y, time) {
    const flakeX = x + (Math.random() - 0.5) * 30;
    const flakeY = y + (Math.random() - 0.5) * 30 - 20;
    const size = 1 + Math.random() * 2;

    ctx.save();
    ctx.translate(flakeX, flakeY);
    ctx.rotate(time);

    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
    ctx.lineWidth = 1;

    for (let i = 0; i < 6; i++) {
      ctx.rotate(Math.PI / 3);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(size * 2, 0);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(size * 0.7, -size * 0.7);
      ctx.lineTo(size * 0.7, size * 0.7);
      ctx.stroke();
    }

    ctx.restore();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\LaserTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\LaserTower.js =====

import { BaseTower } from "./BaseTower.js";
import { spawnBeam } from "../effects.js";
import { ctx } from "../core.js";

export class LaserTower extends BaseTower {
  static SPEC = {
    name: "Laser",
    cost: 250,
    range: 150,
    fireRate: 12,
    dmg: 5,
    beam: true,
    color: "#ff69e0",
  };

  fireBeam(start, end, color) {
    spawnBeam(start, end, color);
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw high-tech base platform with glow
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Platform glow effect
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 22);
    gradient.addColorStop(0, "rgba(255, 105, 224, 0.3)");
    gradient.addColorStop(1, "rgba(255, 105, 224, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with energy effect
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw tower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main housing - futuristic design
    ctx.fillStyle = "#2a2a3a";
    ctx.beginPath();
    ctx.roundRect(-10, -12, 20, 24, 8);
    ctx.fill();

    // Energy core housing
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fill();

    // Pulsing energy core
    const pulseSize = 6 + Math.sin(time * 5) * 1.5;
    const coreAlpha = 0.7 + Math.sin(time * 3) * 0.3;

    ctx.fillStyle = `rgba(255, 220, 255, ${coreAlpha})`;
    ctx.beginPath();
    ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "rgba(255, 105, 224, 0.6)";
    ctx.beginPath();
    ctx.arc(0, 0, pulseSize * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // Laser emitter array
    ctx.fillStyle = "#4a4a6a";
    ctx.beginPath();
    ctx.roundRect(8, -8, 16, 16, 4);
    ctx.fill();

    // Laser lenses
    ctx.fillStyle = "#a0a0ff";
    ctx.beginPath();
    ctx.arc(16, -4, 3, 0, Math.PI * 2);
    ctx.arc(16, 0, 3, 0, Math.PI * 2);
    ctx.arc(16, 4, 3, 0, Math.PI * 2);
    ctx.fill();

    // Main laser lens (center)
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(16, 0, 4, 0, Math.PI * 2);
    ctx.fill();

    // Energy conduits
    ctx.strokeStyle = "#ff69e0";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-6, -6);
    ctx.lineTo(6, -6);
    ctx.lineTo(10, -2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-6, 6);
    ctx.lineTo(6, 6);
    ctx.lineTo(10, 2);
    ctx.stroke();

    // Cooling fins/heat sinks
    ctx.fillStyle = "#3a3a5a";
    for (let i = -10; i <= 10; i += 5) {
      ctx.fillRect(-12, i, 4, 2);
    }

    ctx.restore();

    // Draw level indicators with glow effect
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;

      // Glow effect
      ctx.fillStyle = "rgba(255, 105, 224, 0.3)";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Main indicator
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Pulsing effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        const pulse = Math.sin(time * 4) * 2;
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, 3 + pulse, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Add some particle effects around the tower
    if (Math.random() < 0.1) {
      this.drawEnergyParticle(x, y, time);
    }
  }

  drawEnergyParticle(x, y, time) {
    const angle = Math.random() * Math.PI * 2;
    const distance = 15 + Math.random() * 10;
    const size = 1 + Math.random() * 2;

    const particleX = x + Math.cos(angle) * distance;
    const particleY = y + Math.sin(angle) * distance;

    ctx.fillStyle = `rgba(180, 100, 255, ${0.3 + Math.sin(time * 10) * 0.2})`;
    ctx.beginPath();
    ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\MissileTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\MissileTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, projectiles, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnExplosion, spawnMuzzle } from "../effects.js";
import { Missile } from "../missile.js"; // We'll create this special projectile

export class MissileTower extends BaseTower {
  static SPEC = {
    name: "Missile Tower",
    cost: 280,
    range: 160,
    fireRate: 0.8,
    dmg: 70,
    splash: 80,
    bulletSpeed: 180,
    homingStrength: 0.1,
    retarget: true,
    color: "#FF5722",
  };

  // Override spec to include missile properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.4; // Higher multiplier for damage
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.1), // Better range scaling
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      splash: base.splash * (1 + (this.level - 1) * 0.08),
      bulletSpeed: base.bulletSpeed,
      homingStrength: base.homingStrength + (this.level - 1) * 0.02,
      retarget: base.retarget,
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    // pick best target as before
    let best = null;
    let bestScore = -1;
    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);
      if (d <= s.range && e.t > bestScore) {
        best = e;
        bestScore = e.t;
      }
    }

    // If we found a best right now => lock onto it
    if (best) {
      this.lockedTarget = best;
      this.lockTimer = this.LOCK_HOLD;
    } else {
      // If no immediate best, but we have a locked target, keep it for a short time
      if (this.lockedTarget && !this.lockedTarget.dead) {
        const d = dist(this.center, this.lockedTarget.pos);
        if (d <= s.range && this.lockTimer > 0) {
          this.lockTimer -= dt;
          best = this.lockedTarget; // keep aiming at the locked target
        } else {
          // lock expired or target out of range -> clear lock
          this.lockedTarget = null;
          this.lockTimer = 0;
        }
      } else {
        // no locked target, ensure timer cleared
        this.lockTimer = 0;
        this.lockedTarget = null;
      }
    }

    // Only rotate if we have a target (either new best or locked one)
    // Only rotate if we have a target (either new best or locked one)
    if (best) {
      // local coordinates of the missile nose (must match drawMissileInSilo & fireMissile)
      const localX = 0;
      const localY = -30;

      // Include recoil translation used in draw() (translate(0, this.recoilEffect * 2) before rotate)
      const recoilLocal =
        this.recoilEffect && this.recoilEffect > 0 ? this.recoilEffect * 2 : 0;
      const localYWithRecoil = localY + recoilLocal;

      // If target sits exactly at tower centre, do nothing
      if (!(best.pos.x === this.center.x && best.pos.y === this.center.y)) {
        // Start with a reasonable guess (center -> target) but add PI/2 because nose points -Y
        let rotGuess =
          Math.atan2(best.pos.y - this.center.y, best.pos.x - this.center.x) +
          Math.PI / 2;

        // Iterate: compute nose world position for rotGuess, then compute angle from that nose to the target,
        // then add PI/2 to get the rotation that orients the launcher so the nose faces the target.
        for (let i = 0; i < 4; i++) {
          const sx =
            this.center.x +
            Math.cos(rotGuess) * localX -
            Math.sin(rotGuess) * localYWithRecoil;
          const sy =
            this.center.y +
            Math.sin(rotGuess) * localX +
            Math.cos(rotGuess) * localYWithRecoil;

          // angle from nose (sx,sy) to target, then +PI/2 to convert to launcher rotation
          rotGuess = Math.atan2(best.pos.y - sy, best.pos.x - sx) + Math.PI / 2;
        }

        // instant set — or lerp for smooth turning (see notes)
        this.rot = rotGuess;
      }
    }

    // Fire if cooldown is ready and there's a target
    if (this.cool <= 0 && best) {
      this.cool = 1 / s.fireRate;
      this.fireMissile(best, s);

      // keep locked target after firing so it doesn't snap away
      this.lockedTarget = best;
      this.lockTimer = this.LOCK_HOLD;
    }
  }

  fireMissile(target, spec) {
    const c = this.center;

    // Local coordinates of the missile nose in the launcher space
    // (matches drawMissileInSilo: nose cone goes up to about -30)
    const localX = 0;
    const localY = -30;

    // Transform local -> world using rotation matrix (rotate, then translate)
    const startX =
      c.x + Math.cos(this.rot) * localX - Math.sin(this.rot) * localY;
    const startY =
      c.y + Math.sin(this.rot) * localX + Math.cos(this.rot) * localY;

    // Compute initial rotation based on spawn position toward the target
    const initialRot = Math.atan2(target.pos.y - startY, target.pos.x - startX);

    // Create homing missile at the correct position — pass initial rotation
    const missile = new Missile(startX, startY, target, spec, initialRot);
    projectiles.push(missile);

    // Muzzle flash and smoke at the launch position
    spawnMuzzle(startX, startY, initialRot, spec.color);
    this.spawnLaunchSmoke(startX, startY);

    // Tower recoil effect
    this.recoilEffect = 0.3;
  }

  spawnLaunchSmoke(x, y) {
    for (let i = 0; i < 12; i++) {
      const angle = this.rot + Math.PI + (Math.random() - 0.5) * 0.5;
      const speed = 60 + Math.random() * 60;
      const size = 3 + Math.random() * 3;
      const life = 1 + Math.random() * 0.5;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#888888",
        gravity: 0.1,
        fade: 0.92,
        shrink: 0.95,
      });
    }

    // Add some forward thrust particles too
    for (let i = 0; i < 6; i++) {
      const angle = this.rot + (Math.random() - 0.5) * 0.2;
      const speed = 100 + Math.random() * 100;
      const size = 2 + Math.random() * 2;
      const life = 0.5 + Math.random() * 0.3;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#FF5722",
        gravity: 0.05,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw missile base platform
    ctx.fillStyle = "#261a1a";
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Rocket launch pad glow
    const pulse = Math.sin(time * 4) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 28);
    gradient.addColorStop(0, `rgba(255, 87, 34, ${0.6 * pulse})`);
    gradient.addColorStop(1, "rgba(255, 87, 34, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 28, 0, Math.PI * 2);
    ctx.fill();

    // Platform border
    ctx.strokeStyle = "#4d2d2d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.stroke();

    // Draw missile launcher
    ctx.save();
    ctx.translate(x, y);

    // Apply recoil effect if recently fired
    if (this.recoilEffect > 0) {
      ctx.translate(0, this.recoilEffect * 2);
      this.recoilEffect -= 0.05;
    }

    ctx.rotate(this.rot);

    // Launcher base
    ctx.fillStyle = "#3d2d2d";
    ctx.beginPath();
    ctx.roundRect(-14, -10, 28, 20, 5);
    ctx.fill();

    // Launch rails
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-8, -15);
    ctx.lineTo(-8, 15);
    ctx.moveTo(8, -15);
    ctx.lineTo(8, 15);
    ctx.stroke();

    // Missile silo (if no recent fire)
    if (!this.recoilEffect || this.recoilEffect <= 0) {
      this.drawMissileInSilo();
    }

    // Targeting system
    ctx.fillStyle = "#2196F3";
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    // Targeting reticle
    ctx.strokeStyle = "#2196F3";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, Math.PI * 2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-8, 0);
    ctx.lineTo(8, 0);
    ctx.moveTo(0, -8);
    ctx.lineTo(0, 8);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as missile icons
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;

      // Missile icon
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.moveTo(indicatorX - 2, indicatorY - 4);
      ctx.lineTo(indicatorX + 2, indicatorY - 4);
      ctx.lineTo(indicatorX + 2, indicatorY + 4);
      ctx.lineTo(indicatorX - 2, indicatorY + 4);
      ctx.closePath();
      ctx.fill();

      // Missile tip
      ctx.beginPath();
      ctx.moveTo(indicatorX + 2, indicatorY);
      ctx.lineTo(indicatorX + 4, indicatorY);
      ctx.lineTo(indicatorX + 2, indicatorY - 2);
      ctx.closePath();
      ctx.fill();

      // Fire effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawMiniExhaust(indicatorX, indicatorY, time);
      }
    }

    // Random targeting laser effect
    if (Math.random() < 0.05) {
      this.drawTargetingLaser(x, y, time);
    }
  }

  drawMissileInSilo() {
    // Missile body - positioned to fire forward
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.roundRect(-4, -24, 8, 24, 3); // Moved forward (negative Y)
    ctx.fill();

    // Missile stripes
    ctx.fillStyle = "#FF5722";
    ctx.fillRect(-4, -16, 8, 3); // Adjusted positions
    ctx.fillRect(-4, -9, 8, 3); // Adjusted positions

    // Missile nose cone - pointing forward
    ctx.fillStyle = "#FF5722";
    ctx.beginPath();
    ctx.moveTo(-4, -24);
    ctx.lineTo(4, -24);
    ctx.lineTo(0, -30); // Pointing forward (negative Y)
    ctx.closePath();
    ctx.fill();

    // Fins - adjusted position
    ctx.fillStyle = "#FF5722";
    ctx.beginPath();
    ctx.moveTo(-4, -2); // Adjusted position
    ctx.lineTo(-8, -2); // Adjusted position
    ctx.lineTo(-4, 2); // Adjusted position
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(4, -2); // Adjusted position
    ctx.lineTo(8, -2); // Adjusted position
    ctx.lineTo(4, 2); // Adjusted position
    ctx.closePath();
    ctx.fill();
  }

  drawMiniExhaust(x, y, time) {
    const pulse = Math.sin(time * 8) * 0.5 + 1;

    ctx.fillStyle = `rgba(255, 87, 34, ${0.8 * pulse})`;
    ctx.beginPath();
    ctx.arc(x - 4, y, 2 * pulse, 0, Math.PI * 2);
    ctx.fill();
  }

  drawTargetingLaser(x, y, time) {
    const angle = this.rot + (Math.random() - 0.5) * 0.2;
    const length = 30 + Math.random() * 20;

    ctx.strokeStyle = `rgba(33, 150, 243, ${0.6 + Math.sin(time * 10) * 0.4})`;
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 2]);
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\PoisonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\PoisonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnPoisonCloud } from "../effects.js";

export class PoisonTower extends BaseTower {
  static SPEC = {
    name: "Poison Tower",
    cost: 190,
    range: 110,
    fireRate: 1.5,
    dmg: 15,
    dotDamage: 8,
    dotDuration: 4,
    spreadRange: 60,
    cloudDuration: 3,
    color: "#4CAF50",
  };

  // Override spec to include poison properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      dotDamage: base.dotDamage * mult,
      dotDuration: base.dotDuration * (1 + (this.level - 1) * 0.1),
      spreadRange: base.spreadRange * (1 + (this.level - 1) * 0.05),
      cloudDuration: base.cloudDuration * (1 + (this.level - 1) * 0.1),
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    if (this.cool <= 0) {
      let best = null;
      let bestScore = -1;

      for (const e of enemiesList) {
        if (e.dead || e.poisoned) continue; // Don't target already poisoned enemies
        const p = e.pos;
        const d = dist(this.center, p);
        if (d <= s.range && e.t > bestScore) {
          best = e;
          bestScore = e.t;
        }
      }

      if (best) {
        this.cool = 1 / s.fireRate;
        this.rot = Math.atan2(
          best.pos.y - this.center.y,
          best.pos.x - this.center.x
        );
        this.firePoison(best, s);
      }
    }
  }

  firePoison(target, spec) {
    const c = this.center;

    // Initial damage
    target.damage(spec.dmg);

    // Apply poison effect
    this.applyPoisonEffect(target, spec);

    // Create poison cloud at target location
    spawnPoisonCloud(
      target.pos.x,
      target.pos.y,
      spec.cloudDuration,
      spec.spreadRange
    );

    // Visual effects
    this.spawnPoisonParticles(c.x, c.y, target.pos.x, target.pos.y);
    this.spawnDrippingEffect(c.x, c.y);
  }

  applyPoisonEffect(enemy, spec) {
    if (enemy.poisoned) return; // Already poisoned

    enemy.poisoned = true;
    enemy.poisonDamage = spec.dotDamage;
    enemy.poisonDuration = spec.dotDuration;
    enemy.poisonStartTime = performance.now();

    // Start poison damage tick
    const poisonInterval = setInterval(() => {
      if (enemy.dead || !enemy.poisoned) {
        clearInterval(poisonInterval);
        return;
      }

      const elapsed = (performance.now() - enemy.poisonStartTime) / 1000;
      if (elapsed >= enemy.poisonDuration) {
        enemy.poisoned = false;
        clearInterval(poisonInterval);
        return;
      }

      // Apply damage
      enemy.damage(enemy.poisonDamage / 4); // Damage 4 times per second

      // Chance to spread to nearby enemies
      if (Math.random() < 0.2) {
        // 20% chance per tick to spread
        this.spreadPoison(enemy, spec);
      }
    }, 250); // Tick 4 times per second
  }

  spreadPoison(sourceEnemy, spec) {
    for (const e of enemies) {
      if (e.dead || e.poisoned || e === sourceEnemy) continue;

      const d = dist(sourceEnemy.pos, e.pos);
      if (d <= spec.spreadRange) {
        this.applyPoisonEffect(e, spec);
        spawnPoisonCloud(
          e.pos.x,
          e.pos.y,
          spec.cloudDuration / 2,
          spec.spreadRange / 2
        );
        break; // Only spread to one enemy at a time
      }
    }
  }

  spawnPoisonParticles(startX, startY, endX, endY) {
    for (let i = 0; i < 6; i++) {
      const angle = Math.atan2(endY - startY, endX - startX);
      const spread = (Math.random() - 0.5) * 0.5;
      const speed = 120 + Math.random() * 80;
      const size = 2 + Math.random() * 2;
      const life = 0.8 + Math.random() * 0.4;

      particles.push({
        x: startX,
        y: startY,
        vx: Math.cos(angle + spread) * speed,
        vy: Math.sin(angle + spread) * speed,
        life,
        r: size,
        c: "#4CAF50",
        gravity: 0.3,
        fade: 0.9,
      });
    }
  }

  spawnDrippingEffect(x, y) {
    // Create dripping poison effect from tower
    for (let i = 0; i < 3; i++) {
      const angle = Math.random() * Math.PI - Math.PI / 2; // Mostly downward
      const speed = 40 + Math.random() * 30;
      const size = 1.5 + Math.random() * 1.5;
      const life = 1 + Math.random() * 0.5;

      particles.push({
        x: x + (Math.random() - 0.5) * 10,
        y: y + 15,
        vx: Math.cos(angle) * speed * 0.3,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#388E3C",
        gravity: 0.5,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw toxic base platform
    ctx.fillStyle = "#1a261a";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Toxic glow effect
    const pulse = Math.sin(time * 3) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 10, x, y, 25);
    gradient.addColorStop(0, `rgba(76, 175, 80, ${0.5 * pulse})`);
    gradient.addColorStop(1, "rgba(76, 175, 80, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with toxic effect
    ctx.strokeStyle = "#2d4d2d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw toxic container body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main toxic container
    ctx.fillStyle = "#2d4d2d";
    ctx.beginPath();
    ctx.roundRect(-12, -12, 24, 24, 6);
    ctx.fill();

    // Toxic liquid level (animated)
    const liquidLevel = 0.6 + Math.sin(time * 2) * 0.1;
    ctx.fillStyle = "#4CAF50";
    ctx.beginPath();
    ctx.roundRect(-10, 10 - liquidLevel * 20, 20, liquidLevel * 20, 4);
    ctx.fill();

    // Container details
    ctx.strokeStyle = "#388E3C";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-12, -12, 24, 24, 6);
    ctx.stroke();

    // Toxic emitter nozzle
    ctx.fillStyle = "#3d6d3d";
    ctx.beginPath();
    ctx.roundRect(8, -6, 12, 12, 3);
    ctx.fill();

    // Nozzle opening
    ctx.fillStyle = "#1a261a";
    ctx.beginPath();
    ctx.roundRect(16, -4, 4, 8, 1);
    ctx.fill();

    // Bubbles in toxic liquid
    ctx.fillStyle = "#A5D6A7";
    for (let i = 0; i < 3; i++) {
      const bubbleX = -8 + Math.random() * 16;
      const bubbleY = -5 + Math.random() * 10;
      const bubbleSize = 1 + Math.random() * 2;
      const bubblePulse = Math.sin(time * 3 + i) * 0.3 + 1;

      ctx.beginPath();
      ctx.arc(bubbleX, bubbleY, bubbleSize * bubblePulse, 0, Math.PI * 2);
      ctx.fill();
    }

    // Hazard symbols
    ctx.strokeStyle = "#FFEB3B";
    ctx.lineWidth = 2;
    ctx.beginPath();
    // Skull shape
    ctx.arc(0, -5, 4, 0, Math.PI * 2);
    ctx.moveTo(-3, 0);
    ctx.lineTo(3, 0);
    ctx.moveTo(-4, 2);
    ctx.lineTo(4, 2);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as toxic bubbles
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;
      const bubblePulse = Math.sin(time * 4 + i) * 0.5 + 1;

      // Bubble glow
      ctx.fillStyle = `rgba(76, 175, 80, ${0.4 * bubblePulse})`;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5 * bubblePulse, 0, Math.PI * 2);
      ctx.fill();

      // Main bubble
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Bubble highlight
      ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
      ctx.beginPath();
      ctx.arc(indicatorX - 1, indicatorY - 1, 1, 0, Math.PI * 2);
      ctx.fill();
    }

    // Occasional toxic bubbles rising from tower
    if (Math.random() < 0.1) {
      this.drawRisingBubble(x, y, time);
    }

    // Toxic dripping from nozzle
    if (Math.random() < 0.3) {
      this.drawToxicDrip(x, y, time);
    }
  }

  drawRisingBubble(x, y, time) {
    const bubbleX = x + (Math.random() - 0.5) * 15;
    const bubbleY = y - 20 - Math.random() * 10;
    const size = 1.5 + Math.random() * 1.5;

    ctx.fillStyle = "rgba(165, 214, 167, 0.8)";
    ctx.beginPath();
    ctx.arc(bubbleX, bubbleY, size, 0, Math.PI * 2);
    ctx.fill();

    // Bubble highlight
    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
    ctx.beginPath();
    ctx.arc(
      bubbleX - size * 0.3,
      bubbleY - size * 0.3,
      size * 0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  drawToxicDrip(x, y, time) {
    const dripX = x + 18 + (Math.random() - 0.5) * 2;
    const dripLength = 3 + Math.random() * 4;

    ctx.strokeStyle = "#388E3C";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(dripX, y - 5);
    ctx.lineTo(dripX, y - 5 - dripLength);
    ctx.stroke();

    // Drip end
    ctx.fillStyle = "#388E3C";
    ctx.beginPath();
    ctx.arc(dripX, y - 5 - dripLength, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\TeslaTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\TeslaTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies } from "../state.js";
import { spawnLightningArc, spawnElectricExplosion } from "../effects.js";
import { particles } from "../state.js";
import { dist } from "../utils.js";

export class TeslaTower extends BaseTower {
  static SPEC = {
    name: "Tesla Tower",
    cost: 300,
    range: 140,
    fireRate: 1.3,
    dmg: 25,
    chainCount: 3,
    chainRange: 80,
    stunChance: 0.3,
    stunDuration: 1.5,
    color: "#9d4edd",
  };

  // Override spec to include tesla properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      chainCount: base.chainCount + Math.floor(this.level / 2), // +1 chain every 2 levels
      chainRange: base.chainRange * (1 + (this.level - 1) * 0.05),
      stunChance: base.stunChance + (this.level - 1) * 0.05,
      stunDuration: base.stunDuration * (1 + (this.level - 1) * 0.1),
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    if (this.cool <= 0) {
      let best = null;
      let bestScore = -1;

      for (const e of enemiesList) {
        if (e.dead) continue;
        const p = e.pos;
        const d = dist(this.center, p);
        if (d <= s.range && e.t > bestScore) {
          best = e;
          bestScore = e.t;
        }
      }

      if (best) {
        this.cool = 1 / s.fireRate;
        this.rot = Math.atan2(
          best.pos.y - this.center.y,
          best.pos.x - this.center.x
        );
        this.fireLightning(best, s);
      }
    }
  }

  fireLightning(primaryTarget, spec) {
    const c = this.center;
    const hitEnemies = new Set([primaryTarget]);

    // Damage primary target
    primaryTarget.damage(spec.dmg);
    this.applyStun(primaryTarget, spec);

    // Create primary lightning arc
    spawnLightningArc(c, primaryTarget.pos, spec.color);
    spawnElectricExplosion(primaryTarget.pos.x, primaryTarget.pos.y);

    // Chain to additional targets
    let currentTarget = primaryTarget;
    for (let i = 0; i < spec.chainCount; i++) {
      const nextTarget = this.findNextChainTarget(
        currentTarget,
        hitEnemies,
        spec.chainRange
      );
      if (!nextTarget) break;

      // Damage chained target (reduced damage)
      const chainDmg = spec.dmg * (0.6 - i * 0.1); // 60%, 50%, 40%, etc.
      nextTarget.damage(chainDmg);
      this.applyStun(nextTarget, spec);

      // Create chain lightning arc
      spawnLightningArc(currentTarget.pos, nextTarget.pos, spec.color);
      spawnElectricExplosion(nextTarget.pos.x, nextTarget.pos.y);

      hitEnemies.add(nextTarget);
      currentTarget = nextTarget;
    }

    // Visual effects on the tower itself
    this.spawnElectricParticles(c.x, c.y);
  }

  findNextChainTarget(currentTarget, hitEnemies, chainRange) {
    let bestTarget = null;
    let bestDistance = Infinity;

    for (const e of enemies) {
      if (e.dead || hitEnemies.has(e)) continue;

      const d = dist(currentTarget.pos, e.pos);
      if (d <= chainRange && d < bestDistance) {
        bestTarget = e;
        bestDistance = d;
      }
    }

    return bestTarget;
  }

  applyStun(enemy, spec) {
    if (Math.random() < spec.stunChance && !enemy.stunned) {
      enemy.stunned = true;
      enemy.originalSpeed = enemy.speed;
      enemy.speed = 0;

      // Set timeout to remove stun
      setTimeout(() => {
        if (!enemy.dead) {
          enemy.stunned = false;
          enemy.speed = enemy.originalSpeed;
          enemy.electricEffect = false;
        }
      }, spec.stunDuration * 1000);

      enemy.electricEffect = true;
      enemy.electricEffectTime = spec.stunDuration;
    }
  }

  spawnElectricParticles(x, y) {
    for (let i = 0; i < 8; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 50 + Math.random() * 100;
      const size = 1 + Math.random() * 2;
      const life = 0.3 + Math.random() * 0.2;

      // Use the imported particles array instead of window.particles
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#e0aaff",
        gravity: 0.1,
        fade: 0.9,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw electrified base platform
    ctx.fillStyle = "#1a1426";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Electric glow effect
    const pulse = Math.sin(time * 5) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 10, x, y, 25);
    gradient.addColorStop(0, `rgba(157, 78, 221, ${0.6 * pulse})`);
    gradient.addColorStop(1, "rgba(157, 78, 221, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with electric effect
    ctx.strokeStyle = "#5a2d91";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw Tesla coil body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main coil base
    ctx.fillStyle = "#2a1a3a";
    ctx.beginPath();
    ctx.roundRect(-12, -14, 24, 28, 8);
    ctx.fill();

    // Tesla coil primary
    ctx.fillStyle = "#3a2a4a";
    ctx.beginPath();
    ctx.roundRect(-8, -16, 16, 32, 6);
    ctx.fill();

    // Coil windings
    ctx.strokeStyle = "#7d5ba6";
    ctx.lineWidth = 2;
    for (let i = -12; i <= 12; i += 4) {
      ctx.beginPath();
      ctx.arc(0, i, 6, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Top electrode (Tesla ball)
    ctx.fillStyle = "#e0aaff";
    ctx.beginPath();
    ctx.arc(0, -20, 6, 0, Math.PI * 2);
    ctx.fill();

    // Electric arc effect from top electrode
    const arcPulse = Math.sin(time * 10) * 2;
    ctx.strokeStyle = `rgba(224, 170, 255, ${0.7 + Math.sin(time * 15) * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, -26);
    for (let i = 0; i < 3; i++) {
      const offsetX = (Math.random() - 0.5) * 8;
      const offsetY = -30 - i * 4 + (Math.random() - 0.5) * 3;
      ctx.lineTo(offsetX, offsetY);
    }
    ctx.stroke();

    // Secondary coils
    ctx.fillStyle = "#4a3a5a";
    ctx.beginPath();
    ctx.roundRect(10, -10, 6, 20, 2);
    ctx.fill();

    ctx.beginPath();
    ctx.roundRect(-16, -10, 6, 20, 2);
    ctx.fill();

    // Energy conduits
    ctx.strokeStyle = "#9d4edd";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-8, 12);
    ctx.lineTo(-12, 16);
    ctx.moveTo(8, 12);
    ctx.lineTo(12, 16);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as electric orbs
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;
      const orbPulse = Math.sin(time * 4 + i) * 0.5 + 1;

      // Energy glow
      ctx.fillStyle = `rgba(157, 78, 221, ${0.4 * orbPulse})`;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5 * orbPulse, 0, Math.PI * 2);
      ctx.fill();

      // Main orb
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Electric spark effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawElectricSpark(indicatorX, indicatorY, time);
      }
    }

    // Random electric arcs between tower parts
    if (Math.random() < 0.1) {
      this.drawRandomArc(x, y, time);
    }
  }

  drawElectricSpark(x, y, time) {
    const angle = Math.random() * Math.PI * 2;
    const length = 5 + Math.random() * 8;

    ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 + Math.sin(time * 20) * 0.2})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y);

    for (let i = 0; i < 3; i++) {
      const segX = x + (Math.cos(angle) * length * (i + 1)) / 3;
      const segY = y + (Math.sin(angle) * length * (i + 1)) / 3;
      const offsetX = (Math.random() - 0.5) * 3;
      const offsetY = (Math.random() - 0.5) * 3;
      ctx.lineTo(segX + offsetX, segY + offsetY);
    }

    ctx.stroke();
  }

  drawRandomArc(x, y, time) {
    const startAngle = Math.random() * Math.PI * 2;
    const endAngle = startAngle + (Math.random() - 0.5) * Math.PI;
    const startDist = 15 + Math.random() * 10;
    const endDist = 5 + Math.random() * 8;

    const startX = x + Math.cos(startAngle) * startDist;
    const startY = y + Math.sin(startAngle) * startDist;
    const endX = x + Math.cos(endAngle) * endDist;
    const endY = y + Math.sin(endAngle) * endDist;

    ctx.strokeStyle = `rgba(224, 170, 255, ${0.7 + Math.sin(time * 20) * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(startX, startY);

    // Create jagged lightning effect
    const segments = 5;
    const dx = (endX - startX) / segments;
    const dy = (endY - startY) / segments;

    for (let i = 1; i <= segments; i++) {
      const segX = startX + dx * i;
      const segY = startY + dy * i;
      const offsetX = (Math.random() - 0.5) * 8;
      const offsetY = (Math.random() - 0.5) * 8;
      ctx.lineTo(segX + offsetX, segY + offsetY);
    }

    ctx.stroke();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\BaseTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\BaseTower.js =====

import { ctx } from "../core.js";
import { dist } from "../utils.js";
import { spawnMuzzle } from "../effects.js";
import { projectiles } from "../state.js";
import { Bullet } from "../bullet.js";
import { roundRect } from "../helpers.js";

export class BaseTower {
  constructor(gx, gy, key) {
    this.gx = gx;
    this.gy = gy;
    this.key = key;
    this.level = 1;
    this.cool = 0;
    this.rot = 0;
  }

  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      bulletSpeed: base.bulletSpeed,
      splash: base.splash || 0,
      beam: base.beam || false,
      color: base.color,
      cost: base.cost,
    };
  }

  get center() {
    return { x: this.gx * 40 + 20, y: this.gy * 40 + 20 };
  }

  upgradeCost() {
    return Math.round(this.spec().cost * (0.75 + this.level * 0.75));
  }

  sellValue() {
    return this.spec().cost * 0.7 + (this.level - 1) * this.spec().cost * 0.35;
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;
    let best = null,
      bestScore = -1;

    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);
      if (d <= s.range && e.t > bestScore) {
        best = e;
        bestScore = e.t;
      }
    }

    if (!best) return;
    const c = this.center,
      bp = best.pos;
    this.rot = Math.atan2(bp.y - c.y, bp.x - c.x);

    if (s.beam) {
      const dps = s.dmg * 60;
      if (this.cool <= 0) {
        best.damage(dps * dt);
        this.fireBeam(c, bp, s.color);
      }
      return;
    }

    if (this.cool <= 0) {
      this.cool = 1 / s.fireRate;
      this.fireProjectile(c, best, s);
    }
  }

  fireProjectile(center, target, spec) {
    projectiles.push(new Bullet(center.x, center.y, target, spec));
    spawnMuzzle(center.x, center.y, this.rot, spec.color);
  }

  fireBeam(start, end, color) {
    // This will be implemented in the LaserTower class
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    roundRect(x - 16, y - 16, 32, 32, 8, "#0e1626", true, "#223c62");

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);
    ctx.fillStyle = s.color;

    // Default single barrel
    roundRect(-8, -8, 16, 16, 4, s.color, true);

    ctx.fillStyle = "#fff";
    ctx.fillRect(0, -3, 14, 6); // muzzle indicator
    ctx.restore();

    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.fillRect(x - 10 + i * 6, y + 18, 4, 4);
    }
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\CannonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\CannonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";

export class CannonTower extends BaseTower {
  static SPEC = {
    name: "Cannon",
    cost: 120,
    range: 140,
    fireRate: 1.2,
    dmg: 55,
    splash: 60,
    bulletSpeed: 260,
    color: "#f6c66a",
  };

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    // Draw base platform
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Draw platform border
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw cannon body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Cannon base
    ctx.fillStyle = "#3a3a4a";
    ctx.fillRect(-12, -8, 24, 16);

    // Cannon barrel - main body
    const gradient = ctx.createLinearGradient(0, -10, 0, 10);
    gradient.addColorStop(0, "#8a7a6a");
    gradient.addColorStop(0.5, "#b5a892");
    gradient.addColorStop(1, "#8a7a6a");
    ctx.fillStyle = gradient;

    // Draw barrel with rounded front
    ctx.beginPath();
    ctx.roundRect(-8, -6, 30, 12, 6);
    ctx.fill();

    // Barrel rings/bands
    ctx.fillStyle = "#5a5a6a";
    ctx.fillRect(-5, -7, 3, 14);
    ctx.fillRect(5, -7, 3, 14);
    ctx.fillRect(15, -7, 3, 14);

    // Cannon muzzle
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.arc(22, 0, 6, -Math.PI / 2, Math.PI / 2);
    ctx.fill();

    // Cannon interior (dark hole)
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(24, 0, 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Draw level indicators
    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(x - 10 + i * 6, y + 18, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\DoubleCannonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\DoubleCannonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { projectiles } from "../state.js";
import { spawnMuzzle } from "../effects.js";
import { Bullet } from "../bullet.js";
import { ctx } from "../core.js";

export class DoubleCannonTower extends BaseTower {
  static SPEC = {
    name: "Double Canon",
    cost: 160,
    range: 120,
    fireRate: 0.9,
    dmg: 75,
    splash: 55,
    bulletSpeed: 240,
    color: "#f00",
  };

  fireProjectile(center, target, spec) {
    const offset = 8; // Increased offset for wider barrels
    const sin = Math.sin(this.rot);
    const cos = Math.cos(this.rot);

    // left barrel
    projectiles.push(
      new Bullet(center.x - sin * offset, center.y + cos * offset, target, spec)
    );

    // right barrel
    projectiles.push(
      new Bullet(center.x + sin * offset, center.y - cos * offset, target, spec)
    );

    spawnMuzzle(
      center.x - sin * offset,
      center.y + cos * offset,
      this.rot,
      spec.color
    );
    spawnMuzzle(
      center.x + sin * offset,
      center.y - cos * offset,
      this.rot,
      spec.color
    );
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    // Draw base platform
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Draw platform border
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw cannon mounting platform
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Mounting base
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.roundRect(-14, -10, 28, 20, 6);
    ctx.fill();

    // Draw two cannon barrels
    const barrelOffset = 8;

    // Left cannon
    this.drawCannonBarrel(-barrelOffset, 0, s.color);

    // Right cannon
    this.drawCannonBarrel(barrelOffset, 0, s.color);

    // Central mounting hardware
    ctx.fillStyle = "#5a5a6a";
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    // Bolts on mounting platform
    ctx.fillStyle = "#7a7a8a";
    ctx.beginPath();
    ctx.arc(-10, -6, 2, 0, Math.PI * 2);
    ctx.arc(10, -6, 2, 0, Math.PI * 2);
    ctx.arc(-10, 6, 2, 0, Math.PI * 2);
    ctx.arc(10, 6, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Draw level indicators
    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(x - 12 + i * 6, y + 22, 3, 0, Math.PI * 2);
      ctx.fill();

      // Add glow effect for higher levels
      if (this.level > 2 && i >= this.level - 2) {
        ctx.fillStyle = "rgba(255, 100, 100, 0.4)";
        ctx.beginPath();
        ctx.arc(x - 12 + i * 6, y + 22, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  drawCannonBarrel(xOffset, yOffset, color) {
    // Cannon barrel - main body
    const gradient = ctx.createLinearGradient(xOffset - 5, -8, xOffset - 5, 8);
    gradient.addColorStop(0, "#9a8a7a");
    gradient.addColorStop(0.5, "#c5b8a2");
    gradient.addColorStop(1, "#9a8a7a");
    ctx.fillStyle = gradient;

    // Draw barrel with rounded front
    ctx.beginPath();
    ctx.roundRect(xOffset - 8, -5, 26, 10, 5);
    ctx.fill();

    // Barrel rings/bands
    ctx.fillStyle = "#6a6a7a";
    ctx.fillRect(xOffset - 5, -6, 3, 12);
    ctx.fillRect(xOffset + 5, -6, 3, 12);
    ctx.fillRect(xOffset + 15, -6, 3, 12);

    // Cannon muzzle
    ctx.fillStyle = "#5a5a6a";
    ctx.beginPath();
    ctx.arc(xOffset + 18, 0, 5, -Math.PI / 2, Math.PI / 2);
    ctx.fill();

    // Cannon interior (dark hole)
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(xOffset + 20, 0, 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Red accent on barrel (matching tower color)
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(xOffset - 2, 0, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\FlamethrowerTower.js =====

// ===== FILE: FlamethrowerTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnExplosion } from "../effects.js";

export class FlamethrowerTower extends BaseTower {
  static SPEC = {
    name: "Flamethrower",
    cost: 140,
    range: 80,
    fireRate: 15, // High fire rate for continuous stream
    dmg: 8,
    burnDamage: 6,
    burnDuration: 3,
    coneAngle: Math.PI / 3, // 60 degree cone
    spreadChance: 0.4,
    spreadRange: 40,
    fuelCapacity: 500,
    color: "#FF6B35",
  };

  constructor(gx, gy, key) {
    super(gx, gy, key);
    this.fuel = this.constructor.SPEC.fuelCapacity;
    this.refuelCooldown = 0;
    this.isFiring = false;
    this.fireStream = [];
    this.targetAngle = 0;
    this.flameThrowerEffect = 0;
    // ensure rot exists (BaseTower probably sets it; if not, default)
    if (this.rot === undefined) this.rot = 0;
  }

  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.4; // Higher multiplier for damage
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.1),
      fireRate: base.fireRate * 1,
      dmg: base.dmg * mult,
      burnDamage: base.burnDamage * mult,
      burnDuration: base.burnDuration * (1 + (this.level - 1) * 0.1),
      coneAngle: base.coneAngle + (this.level - 1) * 0.05, // Wider cone at higher levels
      spreadChance: base.spreadChance + (this.level - 1) * 0.05,
      spreadRange: base.spreadRange * (1 + (this.level - 1) * 0.05),
      fuelCapacity: base.fuelCapacity * (1 + (this.level - 1) * 0.2),
      color: base.color,
      cost: base.cost,
    };
  }

  // small helper to normalize angles to [-PI, PI]
  normalizeAngle(a) {
    return Math.atan2(Math.sin(a), Math.cos(a));
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;
    this.refuelCooldown -= dt;
    this.flameThrowerEffect = Math.max(0, this.flameThrowerEffect - dt * 3);

    // Refuel when not firing and cooldown is ready
    if (
      !this.isFiring &&
      this.refuelCooldown <= 0 &&
      this.fuel < s.fuelCapacity
    ) {
      this.fuel = Math.min(
        s.fuelCapacity,
        this.fuel + s.fuelCapacity * dt * 0.5
      );
    }

    // 1) Collect enemies that are within range (all directions)
    const inRange = [];
    const center = this.center;
    for (const enemy of enemiesList) {
      if (enemy.dead) continue;
      const d = dist(center, enemy.pos);
      if (d <= s.range) {
        const angle = Math.atan2(
          enemy.pos.y - center.y,
          enemy.pos.x - center.x
        );
        inRange.push({ enemy, d, angle });
      }
    }

    // 2) If any in range, pick the closest and set targetAngle to it
    if (inRange.length > 0 && this.fuel > 0) {
      inRange.sort((a, b) => a.d - b.d);
      const closest = inRange[0];
      this.targetAngle = closest.angle;

      // Smoothly rotate toward targetAngle (shortest path)
      const angleDiff = this.normalizeAngle(this.targetAngle - this.rot);
      const rotateSpeed = 5; // tweak this to rotate faster / slower
      // scale by dt, but clamp to avoid overshoot when dt large
      const step = angleDiff * Math.min(1, dt * rotateSpeed);
      this.rot = this.normalizeAngle(this.rot + step);

      // 3) Now find enemies inside the cone centered on targetAngle
      const enemiesInCone = this.getEnemiesInConeByCenter(
        enemiesList,
        s,
        this.targetAngle
      );

      if (enemiesInCone.length > 0) {
        // Fire at fireRate; continuous effect handled visually when isFiring is true
        if (this.cool <= 0) {
          this.cool = 1 / s.fireRate;
          this.fireFlame(enemiesInCone, s);
        }
        this.isFiring = true;
        // consume fuel continuously while firing
        this.fuel = Math.max(0, this.fuel - dt * 20);
        this.flameThrowerEffect = 1.0;
      } else {
        this.isFiring = false;
      }
    } else {
      this.isFiring = false;
    }

    // Update fire stream particles
    this.updateFireStream(dt);
  }

  // Checks cone centered on given centerAngle (so detection is independent of current rot)
  getEnemiesInConeByCenter(enemiesList, spec, centerAngle) {
    const enemiesInCone = [];
    const center = this.center;

    for (const enemy of enemiesList) {
      if (enemy.dead) continue;

      const d = dist(center, enemy.pos);
      if (d > spec.range) continue;

      // Calculate angle to enemy
      const angleToEnemy = Math.atan2(
        enemy.pos.y - center.y,
        enemy.pos.x - center.x
      );

      // Calculate angle difference relative to the cone center (centerAngle)
      let angleDiff = angleToEnemy - centerAngle;
      // Normalize angle difference to [-π, π]
      angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));

      // Check if enemy is within cone
      if (Math.abs(angleDiff) <= spec.coneAngle / 2) {
        enemiesInCone.push(enemy);
      }
    }

    return enemiesInCone;
  }

  // kept your original getEnemiesInCone for compatibility if other code uses it
  getEnemiesInCone(enemiesList, spec) {
    return this.getEnemiesInConeByCenter(enemiesList, spec, this.rot);
  }

  fireFlame(enemiesInCone, spec) {
    const center = this.center;
    const fuelRatio = Math.max(0, this.fuel / spec.fuelCapacity); // 0 to 1

    // Determine damage multiplier based on fuel
    let damageMultiplier = 1;
    if (fuelRatio >= 0.5) {
      damageMultiplier = 1; // full damage
    } else if (fuelRatio > 0) {
      damageMultiplier = 0.8; // 20% reduction
    } else {
      damageMultiplier = 0.5; // 50% reduction
    }

    for (const enemy of enemiesInCone) {
      const d = dist(center, enemy.pos);
      const damageFalloff = Math.max(0.3, 1 - d / spec.range);

      const finalDamage = spec.dmg * damageFalloff * damageMultiplier;
      enemy.damage(finalDamage);

      // Burn effect can also be scaled if desired
      const burnDamage = spec.burnDamage * damageMultiplier;
      this.applyBurnEffect(enemy, { ...spec, burnDamage });

      if (Math.random() < spec.spreadChance) {
        this.spreadFire(enemy, spec);
      }
    }

    this.createFireStream(center, spec);
    this.spawnFlameParticles(center, spec);
  }

  applyBurnEffect(enemy, spec) {
    if (enemy.burning) {
      // Refresh burn duration
      enemy.burnDuration = spec.burnDuration;
      return;
    }

    enemy.burning = true;
    enemy.burnDamage = spec.burnDamage;
    enemy.burnDuration = spec.burnDuration;
    enemy.burnStartTime = performance.now();

    // Start burn damage tick
    const burnInterval = setInterval(() => {
      if (enemy.dead || !enemy.burning) {
        clearInterval(burnInterval);
        return;
      }

      const elapsed = (performance.now() - enemy.burnStartTime) / 1000;
      if (elapsed >= enemy.burnDuration) {
        enemy.burning = false;
        clearInterval(burnInterval);
        return;
      }

      // Apply burn damage
      enemy.damage(enemy.burnDamage / 2); // Damage 2 times per second
    }, 500); // Tick every 0.5 seconds
  }

  spreadFire(sourceEnemy, spec) {
    for (const e of enemies) {
      if (e.dead || e.burning || e === sourceEnemy) continue;

      const d = dist(sourceEnemy.pos, e.pos);
      if (d <= spec.spreadRange) {
        this.applyBurnEffect(e, spec);
        this.spawnSpreadFireEffect(sourceEnemy.pos, e.pos);
        break; // Only spread to one enemy at a time
      }
    }
  }

  createFireStream(center, spec) {
    // Create continuous flame stream effect
    const streamLength = spec.range;
    const particleCount = 8;

    for (let i = 0; i < particleCount; i++) {
      const distance = (i / particleCount) * streamLength;
      const spread = (spec.coneAngle / 2) * (distance / streamLength); // Cone gets wider with distance

      const angle = this.rot + (Math.random() - 0.5) * spread;
      const x = center.x + Math.cos(angle) * distance;
      const y = center.y + Math.sin(angle) * distance;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * 50 + (Math.random() - 0.5) * 30,
        vy: Math.sin(angle) * 50 + (Math.random() - 0.5) * 30,
        life: 0.3 + Math.random() * 0.2,
        r: 3 + Math.random() * 2,
        c: this.getFlameColor(),
        gravity: -0.2, // Fire rises
        fade: 0.85,
      });
    }
  }

  spawnFlameParticles(center, spec) {
    for (let i = 0; i < 12; i++) {
      const angle = this.rot + (Math.random() - 0.5) * spec.coneAngle;
      const speed = 80 + Math.random() * 60;
      const distance = Math.random() * spec.range * 0.7;

      const startX = center.x + Math.cos(angle) * distance;
      const startY = center.y + Math.sin(angle) * distance;

      particles.push({
        x: startX,
        y: startY,
        vx: Math.cos(angle) * speed * 0.5,
        vy: Math.sin(angle) * speed * 0.5,
        life: 0.4 + Math.random() * 0.3,
        r: 2 + Math.random() * 3,
        c: this.getFlameColor(),
        gravity: -0.15,
        fade: 0.9,
      });
    }
  }

  spawnSpreadFireEffect(from, to) {
    for (let i = 0; i < 6; i++) {
      const t = i / 5; // Interpolation factor
      const x = from.x + (to.x - from.x) * t;
      const y = from.y + (to.y - from.y) * t;

      particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 40,
        vy: (Math.random() - 0.5) * 40,
        life: 0.5 + Math.random() * 0.3,
        r: 2 + Math.random() * 2,
        c: this.getFlameColor(),
        gravity: -0.1,
        fade: 0.9,
      });
    }
  }

  updateFireStream(dt) {
    // Clean up old fire stream particles
    this.fireStream = this.fireStream.filter((p) => p.life > 0);
  }

  getFlameColor() {
    const colors = ["#FF6B35", "#FF8C42", "#FF4500", "#FFA500", "#FFFF00"];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw industrial base platform
    ctx.fillStyle = "#2a1a1a";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Heat glow effect when firing
    if (this.flameThrowerEffect > 0) {
      const intensity = this.flameThrowerEffect;
      const gradient = ctx.createRadialGradient(x, y, 10, x, y, 30);
      gradient.addColorStop(0, `rgba(255, 107, 53, ${0.6 * intensity})`);
      gradient.addColorStop(1, "rgba(255, 107, 53, 0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI * 2);
      ctx.fill();
    }

    // Platform border
    ctx.strokeStyle = "#4d3d3d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw flamethrower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main body - industrial tank design
    ctx.fillStyle = "#3a3a4a";
    ctx.beginPath();
    ctx.roundRect(-14, -12, 28, 24, 6);
    ctx.fill();

    // Fuel tank
    ctx.fillStyle = "#2a2a3a";
    ctx.beginPath();
    ctx.roundRect(-12, -10, 24, 20, 4);
    ctx.fill();

    // Fuel level indicator
    const fuelLevel = this.fuel / s.fuelCapacity;
    ctx.fillStyle =
      fuelLevel > 0.5 ? "#4CAF50" : fuelLevel > 0.25 ? "#FFC107" : "#F44336";
    ctx.beginPath();
    ctx.roundRect(-10, 8 - fuelLevel * 16, 20, fuelLevel * 16, 2);
    ctx.fill();

    // Tank details
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 1.5;
    for (let i = -6; i <= 6; i += 4) {
      ctx.beginPath();
      ctx.arc(0, i, 8, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Flamethrower nozzle
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.roundRect(8, -6, 14, 12, 3);
    ctx.fill();

    // Nozzle tip
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.ellipse(22, 0, 3, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Pilot light (always on)
    ctx.fillStyle = "#0066FF";
    ctx.beginPath();
    ctx.arc(20, -8, 2, 0, Math.PI * 2);
    ctx.fill();

    // Fuel lines
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-8, 8);
    ctx.lineTo(8, 4);
    ctx.lineTo(16, 0);
    ctx.stroke();

    // Pressure gauges
    ctx.strokeStyle = "#777";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(-8, -6, 3, 0, Math.PI * 2);
    ctx.arc(8, -8, 3, 0, Math.PI * 2);
    ctx.stroke();

    // Gauge needles
    ctx.strokeStyle = "#FF0000";
    ctx.lineWidth = 1.5;
    const gaugeAngle = time * 3 + Math.sin(time * 5) * 0.5;
    ctx.beginPath();
    ctx.moveTo(-8, -6);
    ctx.lineTo(-8 + Math.cos(gaugeAngle) * 2, -6 + Math.sin(gaugeAngle) * 2);
    ctx.stroke();

    // Warning labels
    ctx.fillStyle = "#FFEB3B";
    ctx.fillRect(-6, 2, 3, 2);
    ctx.fillRect(4, -2, 3, 2);

    // Ignition system
    if (this.isFiring) {
      // Show active flame at nozzle
      ctx.fillStyle = this.getFlameColor();
      ctx.beginPath();
      ctx.ellipse(24, 0, 4, 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Flame stream
      for (let i = 1; i <= 5; i++) {
        const flameX = 24 + i * 8;
        const flameSize = 6 - i;
        const flameSpread = i * 2;

        ctx.fillStyle = this.getFlameColor();
        ctx.globalAlpha = 0.7 - i * 0.1;
        ctx.beginPath();
        ctx.ellipse(flameX, 0, flameSize, flameSpread, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    // Draw level indicators as fuel canisters
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;

      // Canister
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.roundRect(indicatorX - 2, indicatorY - 4, 4, 8, 1);
      ctx.fill();

      // Canister top
      ctx.fillStyle = "#888";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY - 4, 2, 0, Math.PI * 2);
      ctx.fill();

      // Flame effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawMiniFlame(indicatorX, indicatorY - 6, time);
      }
    }

    // Draw fuel meter
    this.drawFuelMeter(x, y - 30, s);

    // Heat shimmer effect when firing
    if (this.isFiring && Math.random() < 0.3) {
      this.drawHeatShimmer(x, y, time);
    }
  }

  drawFuelMeter(x, y, spec) {
    const fuelPercent = this.fuel / spec.fuelCapacity;
    const meterWidth = 30;
    const meterHeight = 4;

    // Meter background
    ctx.fillStyle = "#333";
    ctx.fillRect(x - meterWidth / 2, y, meterWidth, meterHeight);

    // Fuel level
    const fuelColor =
      fuelPercent > 0.5
        ? "#4CAF50"
        : fuelPercent > 0.25
        ? "#FFC107"
        : "#F44336";
    ctx.fillStyle = fuelColor;
    ctx.fillRect(x - meterWidth / 2, y, meterWidth * fuelPercent, meterHeight);

    // Meter border
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 1;
    ctx.strokeRect(x - meterWidth / 2, y, meterWidth, meterHeight);
  }

  drawMiniFlame(x, y, time) {
    const flameHeight = 3 + Math.sin(time * 10) * 1;

    ctx.fillStyle = "#FF6B35";
    ctx.beginPath();
    ctx.ellipse(x, y, 1.5, flameHeight, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#FFFF00";
    ctx.beginPath();
    ctx.ellipse(
      x,
      y + flameHeight * 0.3,
      0.8,
      flameHeight * 0.6,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  drawHeatShimmer(x, y, time) {
    ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
    ctx.lineWidth = 1;

    for (let i = 0; i < 3; i++) {
      const shimmerX = x + (Math.random() - 0.5) * 40;
      const shimmerY = y - 10 - i * 8;
      const wave = Math.sin(time * 15 + i) * 3;

      ctx.beginPath();
      ctx.moveTo(shimmerX, shimmerY);
      ctx.quadraticCurveTo(
        shimmerX + wave,
        shimmerY - 8,
        shimmerX,
        shimmerY - 16
      );
      ctx.stroke();
    }
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\GunTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\GunTower.js =====

import { BaseTower } from "./BaseTower.js";

export class GunTower extends BaseTower {
  static SPEC = {
    name: "Gunner",
    cost: 80,
    range: 120,
    fireRate: 6,
    dmg: 12,
    bulletSpeed: 340,
    color: "#6cf",
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\IceTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\IceTower.js =====

import { BaseTower } from "./BaseTower.js";
import { projectiles } from "../state.js";
import { spawnMuzzle } from "../effects.js";
import { Bullet } from "../bullet.js";
import { ctx } from "../core.js";

export class IceTower extends BaseTower {
  static SPEC = {
    name: "Ice Tower",
    cost: 180,
    range: 130,
    fireRate: 2.5,
    dmg: 8,
    slowAmount: 0.6,
    slowDuration: 3,
    freezeChance: 0.2,
    bulletSpeed: 300,
    color: "#6cfaff",
  };

  // Override spec to include ice properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      slowAmount: base.slowAmount,
      slowDuration: base.slowDuration * (1 + (this.level - 1) * 0.1),
      freezeChance: base.freezeChance + (this.level - 1) * 0.05,
      bulletSpeed: base.bulletSpeed,
      color: base.color,
      cost: base.cost,
    };
  }

  fireProjectile(center, target, spec) {
    // Create ice projectile with special properties
    const iceBullet = new Bullet(center.x, center.y, target, spec);

    // Add ice-specific properties to the bullet
    iceBullet.isIce = true;
    iceBullet.slowAmount = spec.slowAmount;
    iceBullet.slowDuration = spec.slowDuration;
    iceBullet.freezeChance = spec.freezeChance;

    projectiles.push(iceBullet);
    spawnMuzzle(center.x, center.y, this.rot, spec.color);

    // Add frost particles effect
    this.spawnFrostParticles(center.x, center.y);
  }

  spawnFrostParticles(x, y) {
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 30 + Math.random() * 50;
      const size = 2 + Math.random() * 3;

      // Add to particles array (you might need to import it)
      const particles = window.particles || [];
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 0.5 + Math.random() * 0.3,
        r: size,
        c: "#a0f0ff",
        gravity: 0.2,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw icy base platform
    ctx.fillStyle = "#0e1a2a";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Icy glow effect
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 22);
    gradient.addColorStop(0, "rgba(108, 250, 255, 0.4)");
    gradient.addColorStop(1, "rgba(108, 250, 255, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Icy platform border
    ctx.strokeStyle = "#2a5a7a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw tower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main icy structure
    ctx.fillStyle = "#a0e0f0";
    ctx.beginPath();
    ctx.roundRect(-10, -10, 20, 20, 6);
    ctx.fill();

    // Ice crystal details
    ctx.fillStyle = "#d0f8ff";
    this.drawIceCrystal(-5, -5, 4, time);
    this.drawIceCrystal(5, -5, 3, time);
    this.drawIceCrystal(0, 5, 5, time);

    // Frost emitter (main crystal)
    const pulse = Math.sin(time * 3) * 1.5;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(12, 0, 4 + pulse, 0, Math.PI * 2);
    ctx.fill();

    // Inner crystal glow
    ctx.fillStyle = "rgba(176, 240, 255, 0.7)";
    ctx.beginPath();
    ctx.arc(12, 0, 2 + pulse * 0.5, 0, Math.PI * 2);
    ctx.fill();

    // Frost patterns on body
    ctx.strokeStyle = "rgba(200, 240, 255, 0.6)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-8, 2);
    ctx.lineTo(-2, -2);
    ctx.lineTo(2, 3);
    ctx.lineTo(6, -1);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as ice shards
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;

      // Glow effect
      ctx.fillStyle = "rgba(108, 250, 255, 0.3)";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 4, 0, Math.PI * 2);
      ctx.fill();

      // Ice shard
      ctx.fillStyle = s.color;
      this.drawIceShard(indicatorX, indicatorY, 3);

      // Frost effect for higher levels
      if (this.level > 2 && i >= this.level - 2) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Occasional snowflake particles
    if (Math.random() < 0.05) {
      this.drawSnowflake(x, y, time);
    }
  }

  drawIceCrystal(x, y, size, time) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(time);

    ctx.beginPath();
    ctx.moveTo(0, -size);
    ctx.lineTo(size * 0.7, 0);
    ctx.lineTo(0, size);
    ctx.lineTo(-size * 0.7, 0);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  drawIceShard(x, y, size) {
    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x + size * 0.7, y);
    ctx.lineTo(x, y + size);
    ctx.lineTo(x - size * 0.7, y);
    ctx.closePath();
    ctx.fill();
  }

  drawSnowflake(x, y, time) {
    const flakeX = x + (Math.random() - 0.5) * 30;
    const flakeY = y + (Math.random() - 0.5) * 30 - 20;
    const size = 1 + Math.random() * 2;

    ctx.save();
    ctx.translate(flakeX, flakeY);
    ctx.rotate(time);

    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
    ctx.lineWidth = 1;

    for (let i = 0; i < 6; i++) {
      ctx.rotate(Math.PI / 3);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(size * 2, 0);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(size * 0.7, -size * 0.7);
      ctx.lineTo(size * 0.7, size * 0.7);
      ctx.stroke();
    }

    ctx.restore();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\LaserTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\LaserTower.js =====

import { BaseTower } from "./BaseTower.js";
import { spawnBeam } from "../effects.js";
import { ctx } from "../core.js";

export class LaserTower extends BaseTower {
  static SPEC = {
    name: "Laser",
    cost: 250,
    range: 150,
    fireRate: 12,
    dmg: 5,
    beam: true,
    color: "#ff69e0",
  };

  fireBeam(start, end, color) {
    spawnBeam(start, end, color);
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw high-tech base platform with glow
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Platform glow effect
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 22);
    gradient.addColorStop(0, "rgba(255, 105, 224, 0.3)");
    gradient.addColorStop(1, "rgba(255, 105, 224, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with energy effect
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw tower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main housing - futuristic design
    ctx.fillStyle = "#2a2a3a";
    ctx.beginPath();
    ctx.roundRect(-10, -12, 20, 24, 8);
    ctx.fill();

    // Energy core housing
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fill();

    // Pulsing energy core
    const pulseSize = 6 + Math.sin(time * 5) * 1.5;
    const coreAlpha = 0.7 + Math.sin(time * 3) * 0.3;

    ctx.fillStyle = `rgba(255, 220, 255, ${coreAlpha})`;
    ctx.beginPath();
    ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "rgba(255, 105, 224, 0.6)";
    ctx.beginPath();
    ctx.arc(0, 0, pulseSize * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // Laser emitter array
    ctx.fillStyle = "#4a4a6a";
    ctx.beginPath();
    ctx.roundRect(8, -8, 16, 16, 4);
    ctx.fill();

    // Laser lenses
    ctx.fillStyle = "#a0a0ff";
    ctx.beginPath();
    ctx.arc(16, -4, 3, 0, Math.PI * 2);
    ctx.arc(16, 0, 3, 0, Math.PI * 2);
    ctx.arc(16, 4, 3, 0, Math.PI * 2);
    ctx.fill();

    // Main laser lens (center)
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(16, 0, 4, 0, Math.PI * 2);
    ctx.fill();

    // Energy conduits
    ctx.strokeStyle = "#ff69e0";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-6, -6);
    ctx.lineTo(6, -6);
    ctx.lineTo(10, -2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-6, 6);
    ctx.lineTo(6, 6);
    ctx.lineTo(10, 2);
    ctx.stroke();

    // Cooling fins/heat sinks
    ctx.fillStyle = "#3a3a5a";
    for (let i = -10; i <= 10; i += 5) {
      ctx.fillRect(-12, i, 4, 2);
    }

    ctx.restore();

    // Draw level indicators with glow effect
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;

      // Glow effect
      ctx.fillStyle = "rgba(255, 105, 224, 0.3)";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Main indicator
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Pulsing effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        const pulse = Math.sin(time * 4) * 2;
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, 3 + pulse, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Add some particle effects around the tower
    if (Math.random() < 0.1) {
      this.drawEnergyParticle(x, y, time);
    }
  }

  drawEnergyParticle(x, y, time) {
    const angle = Math.random() * Math.PI * 2;
    const distance = 15 + Math.random() * 10;
    const size = 1 + Math.random() * 2;

    const particleX = x + Math.cos(angle) * distance;
    const particleY = y + Math.sin(angle) * distance;

    ctx.fillStyle = `rgba(180, 100, 255, ${0.3 + Math.sin(time * 10) * 0.2})`;
    ctx.beginPath();
    ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\MissileTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\MissileTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, projectiles, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnExplosion, spawnMuzzle } from "../effects.js";
import { Missile } from "../missile.js"; // We'll create this special projectile

export class MissileTower extends BaseTower {
  static SPEC = {
    name: "Missile Tower",
    cost: 280,
    range: 160,
    fireRate: 0.8,
    dmg: 70,
    splash: 80,
    bulletSpeed: 180,
    homingStrength: 0.1,
    retarget: true,
    color: "#FF5722",
  };

  // Override spec to include missile properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.4; // Higher multiplier for damage
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.1), // Better range scaling
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      splash: base.splash * (1 + (this.level - 1) * 0.08),
      bulletSpeed: base.bulletSpeed,
      homingStrength: base.homingStrength + (this.level - 1) * 0.02,
      retarget: base.retarget,
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    // pick best target as before
    let best = null;
    let bestScore = -1;
    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);
      if (d <= s.range && e.t > bestScore) {
        best = e;
        bestScore = e.t;
      }
    }

    // If we found a best right now => lock onto it
    if (best) {
      this.lockedTarget = best;
      this.lockTimer = this.LOCK_HOLD;
    } else {
      // If no immediate best, but we have a locked target, keep it for a short time
      if (this.lockedTarget && !this.lockedTarget.dead) {
        const d = dist(this.center, this.lockedTarget.pos);
        if (d <= s.range && this.lockTimer > 0) {
          this.lockTimer -= dt;
          best = this.lockedTarget; // keep aiming at the locked target
        } else {
          // lock expired or target out of range -> clear lock
          this.lockedTarget = null;
          this.lockTimer = 0;
        }
      } else {
        // no locked target, ensure timer cleared
        this.lockTimer = 0;
        this.lockedTarget = null;
      }
    }

    // Only rotate if we have a target (either new best or locked one)
    // Only rotate if we have a target (either new best or locked one)
    if (best) {
      // local coordinates of the missile nose (must match drawMissileInSilo & fireMissile)
      const localX = 0;
      const localY = -30;

      // Include recoil translation used in draw() (translate(0, this.recoilEffect * 2) before rotate)
      const recoilLocal =
        this.recoilEffect && this.recoilEffect > 0 ? this.recoilEffect * 2 : 0;
      const localYWithRecoil = localY + recoilLocal;

      // If target sits exactly at tower centre, do nothing
      if (!(best.pos.x === this.center.x && best.pos.y === this.center.y)) {
        // Start with a reasonable guess (center -> target) but add PI/2 because nose points -Y
        let rotGuess =
          Math.atan2(best.pos.y - this.center.y, best.pos.x - this.center.x) +
          Math.PI / 2;

        // Iterate: compute nose world position for rotGuess, then compute angle from that nose to the target,
        // then add PI/2 to get the rotation that orients the launcher so the nose faces the target.
        for (let i = 0; i < 4; i++) {
          const sx =
            this.center.x +
            Math.cos(rotGuess) * localX -
            Math.sin(rotGuess) * localYWithRecoil;
          const sy =
            this.center.y +
            Math.sin(rotGuess) * localX +
            Math.cos(rotGuess) * localYWithRecoil;

          // angle from nose (sx,sy) to target, then +PI/2 to convert to launcher rotation
          rotGuess = Math.atan2(best.pos.y - sy, best.pos.x - sx) + Math.PI / 2;
        }

        // instant set — or lerp for smooth turning (see notes)
        this.rot = rotGuess;
      }
    }

    // Fire if cooldown is ready and there's a target
    if (this.cool <= 0 && best) {
      this.cool = 1 / s.fireRate;
      this.fireMissile(best, s);

      // keep locked target after firing so it doesn't snap away
      this.lockedTarget = best;
      this.lockTimer = this.LOCK_HOLD;
    }
  }

  fireMissile(target, spec) {
    const c = this.center;

    // Local coordinates of the missile nose in the launcher space
    // (matches drawMissileInSilo: nose cone goes up to about -30)
    const localX = 0;
    const localY = -30;

    // Transform local -> world using rotation matrix (rotate, then translate)
    const startX =
      c.x + Math.cos(this.rot) * localX - Math.sin(this.rot) * localY;
    const startY =
      c.y + Math.sin(this.rot) * localX + Math.cos(this.rot) * localY;

    // Compute initial rotation based on spawn position toward the target
    const initialRot = Math.atan2(target.pos.y - startY, target.pos.x - startX);

    // Create homing missile at the correct position — pass initial rotation
    const missile = new Missile(startX, startY, target, spec, initialRot);
    projectiles.push(missile);

    // Muzzle flash and smoke at the launch position
    spawnMuzzle(startX, startY, initialRot, spec.color);
    this.spawnLaunchSmoke(startX, startY);

    // Tower recoil effect
    this.recoilEffect = 0.3;
  }

  spawnLaunchSmoke(x, y) {
    for (let i = 0; i < 12; i++) {
      const angle = this.rot + Math.PI + (Math.random() - 0.5) * 0.5;
      const speed = 60 + Math.random() * 60;
      const size = 3 + Math.random() * 3;
      const life = 1 + Math.random() * 0.5;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#888888",
        gravity: 0.1,
        fade: 0.92,
        shrink: 0.95,
      });
    }

    // Add some forward thrust particles too
    for (let i = 0; i < 6; i++) {
      const angle = this.rot + (Math.random() - 0.5) * 0.2;
      const speed = 100 + Math.random() * 100;
      const size = 2 + Math.random() * 2;
      const life = 0.5 + Math.random() * 0.3;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#FF5722",
        gravity: 0.05,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw missile base platform
    ctx.fillStyle = "#261a1a";
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Rocket launch pad glow
    const pulse = Math.sin(time * 4) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 28);
    gradient.addColorStop(0, `rgba(255, 87, 34, ${0.6 * pulse})`);
    gradient.addColorStop(1, "rgba(255, 87, 34, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 28, 0, Math.PI * 2);
    ctx.fill();

    // Platform border
    ctx.strokeStyle = "#4d2d2d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.stroke();

    // Draw missile launcher
    ctx.save();
    ctx.translate(x, y);

    // Apply recoil effect if recently fired
    if (this.recoilEffect > 0) {
      ctx.translate(0, this.recoilEffect * 2);
      this.recoilEffect -= 0.05;
    }

    ctx.rotate(this.rot);

    // Launcher base
    ctx.fillStyle = "#3d2d2d";
    ctx.beginPath();
    ctx.roundRect(-14, -10, 28, 20, 5);
    ctx.fill();

    // Launch rails
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-8, -15);
    ctx.lineTo(-8, 15);
    ctx.moveTo(8, -15);
    ctx.lineTo(8, 15);
    ctx.stroke();

    // Missile silo (if no recent fire)
    if (!this.recoilEffect || this.recoilEffect <= 0) {
      this.drawMissileInSilo();
    }

    // Targeting system
    ctx.fillStyle = "#2196F3";
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    // Targeting reticle
    ctx.strokeStyle = "#2196F3";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, Math.PI * 2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-8, 0);
    ctx.lineTo(8, 0);
    ctx.moveTo(0, -8);
    ctx.lineTo(0, 8);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as missile icons
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;

      // Missile icon
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.moveTo(indicatorX - 2, indicatorY - 4);
      ctx.lineTo(indicatorX + 2, indicatorY - 4);
      ctx.lineTo(indicatorX + 2, indicatorY + 4);
      ctx.lineTo(indicatorX - 2, indicatorY + 4);
      ctx.closePath();
      ctx.fill();

      // Missile tip
      ctx.beginPath();
      ctx.moveTo(indicatorX + 2, indicatorY);
      ctx.lineTo(indicatorX + 4, indicatorY);
      ctx.lineTo(indicatorX + 2, indicatorY - 2);
      ctx.closePath();
      ctx.fill();

      // Fire effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawMiniExhaust(indicatorX, indicatorY, time);
      }
    }

    // Random targeting laser effect
    if (Math.random() < 0.05) {
      this.drawTargetingLaser(x, y, time);
    }
  }

  drawMissileInSilo() {
    // Missile body - positioned to fire forward
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.roundRect(-4, -24, 8, 24, 3); // Moved forward (negative Y)
    ctx.fill();

    // Missile stripes
    ctx.fillStyle = "#FF5722";
    ctx.fillRect(-4, -16, 8, 3); // Adjusted positions
    ctx.fillRect(-4, -9, 8, 3); // Adjusted positions

    // Missile nose cone - pointing forward
    ctx.fillStyle = "#FF5722";
    ctx.beginPath();
    ctx.moveTo(-4, -24);
    ctx.lineTo(4, -24);
    ctx.lineTo(0, -30); // Pointing forward (negative Y)
    ctx.closePath();
    ctx.fill();

    // Fins - adjusted position
    ctx.fillStyle = "#FF5722";
    ctx.beginPath();
    ctx.moveTo(-4, -2); // Adjusted position
    ctx.lineTo(-8, -2); // Adjusted position
    ctx.lineTo(-4, 2); // Adjusted position
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(4, -2); // Adjusted position
    ctx.lineTo(8, -2); // Adjusted position
    ctx.lineTo(4, 2); // Adjusted position
    ctx.closePath();
    ctx.fill();
  }

  drawMiniExhaust(x, y, time) {
    const pulse = Math.sin(time * 8) * 0.5 + 1;

    ctx.fillStyle = `rgba(255, 87, 34, ${0.8 * pulse})`;
    ctx.beginPath();
    ctx.arc(x - 4, y, 2 * pulse, 0, Math.PI * 2);
    ctx.fill();
  }

  drawTargetingLaser(x, y, time) {
    const angle = this.rot + (Math.random() - 0.5) * 0.2;
    const length = 30 + Math.random() * 20;

    ctx.strokeStyle = `rgba(33, 150, 243, ${0.6 + Math.sin(time * 10) * 0.4})`;
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 2]);
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\PoisonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\PoisonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnPoisonCloud } from "../effects.js";

export class PoisonTower extends BaseTower {
  static SPEC = {
    name: "Poison Tower",
    cost: 190,
    range: 110,
    fireRate: 1.5,
    dmg: 15,
    dotDamage: 8,
    dotDuration: 4,
    spreadRange: 60,
    cloudDuration: 3,
    color: "#4CAF50",
  };

  // Override spec to include poison properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      dotDamage: base.dotDamage * mult,
      dotDuration: base.dotDuration * (1 + (this.level - 1) * 0.1),
      spreadRange: base.spreadRange * (1 + (this.level - 1) * 0.05),
      cloudDuration: base.cloudDuration * (1 + (this.level - 1) * 0.1),
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    if (this.cool <= 0) {
      let best = null;
      let bestScore = -1;

      for (const e of enemiesList) {
        if (e.dead || e.poisoned) continue; // Don't target already poisoned enemies
        const p = e.pos;
        const d = dist(this.center, p);
        if (d <= s.range && e.t > bestScore) {
          best = e;
          bestScore = e.t;
        }
      }

      if (best) {
        this.cool = 1 / s.fireRate;
        this.rot = Math.atan2(
          best.pos.y - this.center.y,
          best.pos.x - this.center.x
        );
        this.firePoison(best, s);
      }
    }
  }

  firePoison(target, spec) {
    const c = this.center;

    // Initial damage
    target.damage(spec.dmg);

    // Apply poison effect
    this.applyPoisonEffect(target, spec);

    // Create poison cloud at target location
    spawnPoisonCloud(
      target.pos.x,
      target.pos.y,
      spec.cloudDuration,
      spec.spreadRange
    );

    // Visual effects
    this.spawnPoisonParticles(c.x, c.y, target.pos.x, target.pos.y);
    this.spawnDrippingEffect(c.x, c.y);
  }

  applyPoisonEffect(enemy, spec) {
    if (enemy.poisoned) return; // Already poisoned

    enemy.poisoned = true;
    enemy.poisonDamage = spec.dotDamage;
    enemy.poisonDuration = spec.dotDuration;
    enemy.poisonStartTime = performance.now();

    // Start poison damage tick
    const poisonInterval = setInterval(() => {
      if (enemy.dead || !enemy.poisoned) {
        clearInterval(poisonInterval);
        return;
      }

      const elapsed = (performance.now() - enemy.poisonStartTime) / 1000;
      if (elapsed >= enemy.poisonDuration) {
        enemy.poisoned = false;
        clearInterval(poisonInterval);
        return;
      }

      // Apply damage
      enemy.damage(enemy.poisonDamage / 4); // Damage 4 times per second

      // Chance to spread to nearby enemies
      if (Math.random() < 0.2) {
        // 20% chance per tick to spread
        this.spreadPoison(enemy, spec);
      }
    }, 250); // Tick 4 times per second
  }

  spreadPoison(sourceEnemy, spec) {
    for (const e of enemies) {
      if (e.dead || e.poisoned || e === sourceEnemy) continue;

      const d = dist(sourceEnemy.pos, e.pos);
      if (d <= spec.spreadRange) {
        this.applyPoisonEffect(e, spec);
        spawnPoisonCloud(
          e.pos.x,
          e.pos.y,
          spec.cloudDuration / 2,
          spec.spreadRange / 2
        );
        break; // Only spread to one enemy at a time
      }
    }
  }

  spawnPoisonParticles(startX, startY, endX, endY) {
    for (let i = 0; i < 6; i++) {
      const angle = Math.atan2(endY - startY, endX - startX);
      const spread = (Math.random() - 0.5) * 0.5;
      const speed = 120 + Math.random() * 80;
      const size = 2 + Math.random() * 2;
      const life = 0.8 + Math.random() * 0.4;

      particles.push({
        x: startX,
        y: startY,
        vx: Math.cos(angle + spread) * speed,
        vy: Math.sin(angle + spread) * speed,
        life,
        r: size,
        c: "#4CAF50",
        gravity: 0.3,
        fade: 0.9,
      });
    }
  }

  spawnDrippingEffect(x, y) {
    // Create dripping poison effect from tower
    for (let i = 0; i < 3; i++) {
      const angle = Math.random() * Math.PI - Math.PI / 2; // Mostly downward
      const speed = 40 + Math.random() * 30;
      const size = 1.5 + Math.random() * 1.5;
      const life = 1 + Math.random() * 0.5;

      particles.push({
        x: x + (Math.random() - 0.5) * 10,
        y: y + 15,
        vx: Math.cos(angle) * speed * 0.3,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#388E3C",
        gravity: 0.5,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw toxic base platform
    ctx.fillStyle = "#1a261a";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Toxic glow effect
    const pulse = Math.sin(time * 3) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 10, x, y, 25);
    gradient.addColorStop(0, `rgba(76, 175, 80, ${0.5 * pulse})`);
    gradient.addColorStop(1, "rgba(76, 175, 80, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with toxic effect
    ctx.strokeStyle = "#2d4d2d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw toxic container body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main toxic container
    ctx.fillStyle = "#2d4d2d";
    ctx.beginPath();
    ctx.roundRect(-12, -12, 24, 24, 6);
    ctx.fill();

    // Toxic liquid level (animated)
    const liquidLevel = 0.6 + Math.sin(time * 2) * 0.1;
    ctx.fillStyle = "#4CAF50";
    ctx.beginPath();
    ctx.roundRect(-10, 10 - liquidLevel * 20, 20, liquidLevel * 20, 4);
    ctx.fill();

    // Container details
    ctx.strokeStyle = "#388E3C";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-12, -12, 24, 24, 6);
    ctx.stroke();

    // Toxic emitter nozzle
    ctx.fillStyle = "#3d6d3d";
    ctx.beginPath();
    ctx.roundRect(8, -6, 12, 12, 3);
    ctx.fill();

    // Nozzle opening
    ctx.fillStyle = "#1a261a";
    ctx.beginPath();
    ctx.roundRect(16, -4, 4, 8, 1);
    ctx.fill();

    // Bubbles in toxic liquid
    ctx.fillStyle = "#A5D6A7";
    for (let i = 0; i < 3; i++) {
      const bubbleX = -8 + Math.random() * 16;
      const bubbleY = -5 + Math.random() * 10;
      const bubbleSize = 1 + Math.random() * 2;
      const bubblePulse = Math.sin(time * 3 + i) * 0.3 + 1;

      ctx.beginPath();
      ctx.arc(bubbleX, bubbleY, bubbleSize * bubblePulse, 0, Math.PI * 2);
      ctx.fill();
    }

    // Hazard symbols
    ctx.strokeStyle = "#FFEB3B";
    ctx.lineWidth = 2;
    ctx.beginPath();
    // Skull shape
    ctx.arc(0, -5, 4, 0, Math.PI * 2);
    ctx.moveTo(-3, 0);
    ctx.lineTo(3, 0);
    ctx.moveTo(-4, 2);
    ctx.lineTo(4, 2);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as toxic bubbles
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;
      const bubblePulse = Math.sin(time * 4 + i) * 0.5 + 1;

      // Bubble glow
      ctx.fillStyle = `rgba(76, 175, 80, ${0.4 * bubblePulse})`;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5 * bubblePulse, 0, Math.PI * 2);
      ctx.fill();

      // Main bubble
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Bubble highlight
      ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
      ctx.beginPath();
      ctx.arc(indicatorX - 1, indicatorY - 1, 1, 0, Math.PI * 2);
      ctx.fill();
    }

    // Occasional toxic bubbles rising from tower
    if (Math.random() < 0.1) {
      this.drawRisingBubble(x, y, time);
    }

    // Toxic dripping from nozzle
    if (Math.random() < 0.3) {
      this.drawToxicDrip(x, y, time);
    }
  }

  drawRisingBubble(x, y, time) {
    const bubbleX = x + (Math.random() - 0.5) * 15;
    const bubbleY = y - 20 - Math.random() * 10;
    const size = 1.5 + Math.random() * 1.5;

    ctx.fillStyle = "rgba(165, 214, 167, 0.8)";
    ctx.beginPath();
    ctx.arc(bubbleX, bubbleY, size, 0, Math.PI * 2);
    ctx.fill();

    // Bubble highlight
    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
    ctx.beginPath();
    ctx.arc(
      bubbleX - size * 0.3,
      bubbleY - size * 0.3,
      size * 0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  drawToxicDrip(x, y, time) {
    const dripX = x + 18 + (Math.random() - 0.5) * 2;
    const dripLength = 3 + Math.random() * 4;

    ctx.strokeStyle = "#388E3C";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(dripX, y - 5);
    ctx.lineTo(dripX, y - 5 - dripLength);
    ctx.stroke();

    // Drip end
    ctx.fillStyle = "#388E3C";
    ctx.beginPath();
    ctx.arc(dripX, y - 5 - dripLength, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\TeslaTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\TeslaTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies } from "../state.js";
import { spawnLightningArc, spawnElectricExplosion } from "../effects.js";
import { particles } from "../state.js";
import { dist } from "../utils.js";

export class TeslaTower extends BaseTower {
  static SPEC = {
    name: "Tesla Tower",
    cost: 300,
    range: 140,
    fireRate: 1.3,
    dmg: 25,
    chainCount: 3,
    chainRange: 80,
    stunChance: 0.3,
    stunDuration: 1.5,
    color: "#9d4edd",
  };

  // Override spec to include tesla properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      chainCount: base.chainCount + Math.floor(this.level / 2), // +1 chain every 2 levels
      chainRange: base.chainRange * (1 + (this.level - 1) * 0.05),
      stunChance: base.stunChance + (this.level - 1) * 0.05,
      stunDuration: base.stunDuration * (1 + (this.level - 1) * 0.1),
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    if (this.cool <= 0) {
      let best = null;
      let bestScore = -1;

      for (const e of enemiesList) {
        if (e.dead) continue;
        const p = e.pos;
        const d = dist(this.center, p);
        if (d <= s.range && e.t > bestScore) {
          best = e;
          bestScore = e.t;
        }
      }

      if (best) {
        this.cool = 1 / s.fireRate;
        this.rot = Math.atan2(
          best.pos.y - this.center.y,
          best.pos.x - this.center.x
        );
        this.fireLightning(best, s);
      }
    }
  }

  fireLightning(primaryTarget, spec) {
    const c = this.center;
    const hitEnemies = new Set([primaryTarget]);

    // Damage primary target
    primaryTarget.damage(spec.dmg);
    this.applyStun(primaryTarget, spec);

    // Create primary lightning arc
    spawnLightningArc(c, primaryTarget.pos, spec.color);
    spawnElectricExplosion(primaryTarget.pos.x, primaryTarget.pos.y);

    // Chain to additional targets
    let currentTarget = primaryTarget;
    for (let i = 0; i < spec.chainCount; i++) {
      const nextTarget = this.findNextChainTarget(
        currentTarget,
        hitEnemies,
        spec.chainRange
      );
      if (!nextTarget) break;

      // Damage chained target (reduced damage)
      const chainDmg = spec.dmg * (0.6 - i * 0.1); // 60%, 50%, 40%, etc.
      nextTarget.damage(chainDmg);
      this.applyStun(nextTarget, spec);

      // Create chain lightning arc
      spawnLightningArc(currentTarget.pos, nextTarget.pos, spec.color);
      spawnElectricExplosion(nextTarget.pos.x, nextTarget.pos.y);

      hitEnemies.add(nextTarget);
      currentTarget = nextTarget;
    }

    // Visual effects on the tower itself
    this.spawnElectricParticles(c.x, c.y);
  }

  findNextChainTarget(currentTarget, hitEnemies, chainRange) {
    let bestTarget = null;
    let bestDistance = Infinity;

    for (const e of enemies) {
      if (e.dead || hitEnemies.has(e)) continue;

      const d = dist(currentTarget.pos, e.pos);
      if (d <= chainRange && d < bestDistance) {
        bestTarget = e;
        bestDistance = d;
      }
    }

    return bestTarget;
  }

  applyStun(enemy, spec) {
    if (Math.random() < spec.stunChance && !enemy.stunned) {
      enemy.stunned = true;
      enemy.originalSpeed = enemy.speed;
      enemy.speed = 0;

      // Set timeout to remove stun
      setTimeout(() => {
        if (!enemy.dead) {
          enemy.stunned = false;
          enemy.speed = enemy.originalSpeed;
          enemy.electricEffect = false;
        }
      }, spec.stunDuration * 1000);

      enemy.electricEffect = true;
      enemy.electricEffectTime = spec.stunDuration;
    }
  }

  spawnElectricParticles(x, y) {
    for (let i = 0; i < 8; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 50 + Math.random() * 100;
      const size = 1 + Math.random() * 2;
      const life = 0.3 + Math.random() * 0.2;

      // Use the imported particles array instead of window.particles
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#e0aaff",
        gravity: 0.1,
        fade: 0.9,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw electrified base platform
    ctx.fillStyle = "#1a1426";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Electric glow effect
    const pulse = Math.sin(time * 5) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 10, x, y, 25);
    gradient.addColorStop(0, `rgba(157, 78, 221, ${0.6 * pulse})`);
    gradient.addColorStop(1, "rgba(157, 78, 221, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with electric effect
    ctx.strokeStyle = "#5a2d91";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw Tesla coil body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main coil base
    ctx.fillStyle = "#2a1a3a";
    ctx.beginPath();
    ctx.roundRect(-12, -14, 24, 28, 8);
    ctx.fill();

    // Tesla coil primary
    ctx.fillStyle = "#3a2a4a";
    ctx.beginPath();
    ctx.roundRect(-8, -16, 16, 32, 6);
    ctx.fill();

    // Coil windings
    ctx.strokeStyle = "#7d5ba6";
    ctx.lineWidth = 2;
    for (let i = -12; i <= 12; i += 4) {
      ctx.beginPath();
      ctx.arc(0, i, 6, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Top electrode (Tesla ball)
    ctx.fillStyle = "#e0aaff";
    ctx.beginPath();
    ctx.arc(0, -20, 6, 0, Math.PI * 2);
    ctx.fill();

    // Electric arc effect from top electrode
    const arcPulse = Math.sin(time * 10) * 2;
    ctx.strokeStyle = `rgba(224, 170, 255, ${0.7 + Math.sin(time * 15) * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, -26);
    for (let i = 0; i < 3; i++) {
      const offsetX = (Math.random() - 0.5) * 8;
      const offsetY = -30 - i * 4 + (Math.random() - 0.5) * 3;
      ctx.lineTo(offsetX, offsetY);
    }
    ctx.stroke();

    // Secondary coils
    ctx.fillStyle = "#4a3a5a";
    ctx.beginPath();
    ctx.roundRect(10, -10, 6, 20, 2);
    ctx.fill();

    ctx.beginPath();
    ctx.roundRect(-16, -10, 6, 20, 2);
    ctx.fill();

    // Energy conduits
    ctx.strokeStyle = "#9d4edd";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-8, 12);
    ctx.lineTo(-12, 16);
    ctx.moveTo(8, 12);
    ctx.lineTo(12, 16);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as electric orbs
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;
      const orbPulse = Math.sin(time * 4 + i) * 0.5 + 1;

      // Energy glow
      ctx.fillStyle = `rgba(157, 78, 221, ${0.4 * orbPulse})`;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5 * orbPulse, 0, Math.PI * 2);
      ctx.fill();

      // Main orb
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Electric spark effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawElectricSpark(indicatorX, indicatorY, time);
      }
    }

    // Random electric arcs between tower parts
    if (Math.random() < 0.1) {
      this.drawRandomArc(x, y, time);
    }
  }

  drawElectricSpark(x, y, time) {
    const angle = Math.random() * Math.PI * 2;
    const length = 5 + Math.random() * 8;

    ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 + Math.sin(time * 20) * 0.2})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y);

    for (let i = 0; i < 3; i++) {
      const segX = x + (Math.cos(angle) * length * (i + 1)) / 3;
      const segY = y + (Math.sin(angle) * length * (i + 1)) / 3;
      const offsetX = (Math.random() - 0.5) * 3;
      const offsetY = (Math.random() - 0.5) * 3;
      ctx.lineTo(segX + offsetX, segY + offsetY);
    }

    ctx.stroke();
  }

  drawRandomArc(x, y, time) {
    const startAngle = Math.random() * Math.PI * 2;
    const endAngle = startAngle + (Math.random() - 0.5) * Math.PI;
    const startDist = 15 + Math.random() * 10;
    const endDist = 5 + Math.random() * 8;

    const startX = x + Math.cos(startAngle) * startDist;
    const startY = y + Math.sin(startAngle) * startDist;
    const endX = x + Math.cos(endAngle) * endDist;
    const endY = y + Math.sin(endAngle) * endDist;

    ctx.strokeStyle = `rgba(224, 170, 255, ${0.7 + Math.sin(time * 20) * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(startX, startY);

    // Create jagged lightning effect
    const segments = 5;
    const dx = (endX - startX) / segments;
    const dy = (endY - startY) / segments;

    for (let i = 1; i <= segments; i++) {
      const segX = startX + dx * i;
      const segY = startY + dy * i;
      const offsetX = (Math.random() - 0.5) * 8;
      const offsetY = (Math.random() - 0.5) * 8;
      ctx.lineTo(segX + offsetX, segY + offsetY);
    }

    ctx.stroke();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\ArtilleryTower.js =====

// ===== FILE: src/towers/ArtilleryTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, projectiles, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnMuzzle, spawnExplosion } from "../effects.js";
import { ArtilleryShell } from "../artilleryShell.js"; // Special arcing projectile

export class ArtilleryTower extends BaseTower {
  static SPEC = {
    name: "Artillery",
    cost: 500,
    range: 350, // Long range
    fireRate: 0.15, // Very slow firing rate
    dmg: 60, // High damage
    splash: 120, // Large splash radius
    bulletSpeed: 150, // Slow projectiles (for arcing)
    arcHeight: 80, // Height of projectile arc
    minRange: 60, // Minimum range to avoid hitting itself
    color: "#8d6e63",
  };

  // Override spec to include artillery properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.5; // Higher multiplier for damage
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.1),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.08),
      dmg: base.dmg * mult,
      splash: base.splash * (1 + (this.level - 1) * 0.1),
      bulletSpeed: base.bulletSpeed,
      arcHeight: base.arcHeight * (1 + (this.level - 1) * 0.05),
      minRange: base.minRange,
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    // Find best target (prioritize groups of enemies)
    let best = null;
    let bestScore = -1;

    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);

      // Check if in range but not too close
      if (d <= s.range && d >= s.minRange) {
        // Score based on number of enemies near this target
        let nearbyEnemies = 0;
        for (const other of enemiesList) {
          if (other.dead) continue;
          if (dist(p, other.pos) <= s.splash * 0.8) {
            nearbyEnemies++;
          }
        }

        const score = e.t * (1 + nearbyEnemies * 0.3); // Prefer later enemies with groups

        if (score > bestScore) {
          best = e;
          bestScore = score;
        }
      }
    }

    // If we found a target, aim at it
    if (best) {
      const dx = best.pos.x - this.center.x;
      const dy = best.pos.y - this.center.y;
      this.rot = Math.atan2(dy, dx) + Math.PI / 2;
    }

    // Fire if cooldown is ready and there's a target
    if (this.cool <= 0 && best) {
      this.cool = 1 / s.fireRate;
      this.fireArtilleryShot(best, s);
    }
  }

  fireArtilleryShot(target, spec) {
    const c = this.center;

    // Calculate starting position at the mortar barrel
    const barrelLength = 25;
    const startX = c.x + Math.cos(this.rot - Math.PI / 2) * barrelLength;
    const startY = c.y + Math.sin(this.rot - Math.PI / 2) * barrelLength;

    // Create artillery shell with arc trajectory
    const shell = new ArtilleryShell(
      startX,
      startY,
      target.pos.x,
      target.pos.y,
      spec
    );
    projectiles.push(shell);

    // Muzzle flash and smoke
    this.spawnMuzzleBlast(startX, startY);

    // Recoil effect
    this.recoilEffect = 0.4;
  }

  spawnMuzzleBlast(x, y) {
    // Large muzzle blast for artillery
    for (let i = 0; i < 15; i++) {
      const angle = this.rot - Math.PI / 2 + (Math.random() - 0.5) * 0.5;
      const speed = 60 + Math.random() * 60;
      const size = 4 + Math.random() * 3;
      const life = 1.2 + Math.random() * 0.5;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#666",
        gravity: 0.2,
        fade: 0.9,
        shrink: 0.95,
      });
    }

    // Flash
    for (let i = 0; i < 8; i++) {
      const angle = this.rot - Math.PI / 2 + (Math.random() - 0.5) * 0.3;
      const speed = 120 + Math.random() * 120;
      const size = 2 + Math.random() * 2;
      const life = 0.3 + Math.random() * 0.2;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#ff8c00",
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw artillery base
    ctx.fillStyle = "#5d4037";
    ctx.beginPath();
    ctx.arc(x, y, 24, 0, Math.PI * 2);
    ctx.fill();

    // Platform border
    ctx.strokeStyle = "#4e342e";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, y, 24, 0, Math.PI * 2);
    ctx.stroke();

    // Draw artillery body
    ctx.save();
    ctx.translate(x, y);

    // Apply recoil effect if recently fired
    if (this.recoilEffect > 0) {
      ctx.translate(0, this.recoilEffect * 3);
      this.recoilEffect -= 0.03;
    }

    ctx.rotate(this.rot);

    // Mount
    ctx.fillStyle = "#4e342e";
    ctx.beginPath();
    ctx.roundRect(-18, -8, 36, 16, 4);
    ctx.fill();

    // Barrel base
    ctx.fillStyle = "#6d4c41";
    ctx.beginPath();
    ctx.roundRect(-10, -20, 20, 12, 3);
    ctx.fill();

    // Barrel
    ctx.fillStyle = "#5d4037";
    ctx.beginPath();
    ctx.roundRect(-8, -45, 16, 30, 4);
    ctx.fill();

    // Barrel tip
    ctx.fillStyle = "#4e342e";
    ctx.beginPath();
    ctx.roundRect(-7, -50, 14, 8, 3);
    ctx.fill();

    // Aiming mechanism
    ctx.fillStyle = "#3e2723";
    ctx.beginPath();
    ctx.arc(0, -15, 6, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Draw level indicators as explosion icons
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;

      // Explosion icon
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 2, 0, Math.PI * 2);
      ctx.fill();

      // Explosion spikes
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let j = 0; j < 8; j++) {
        const angle = (j * Math.PI * 2) / 8;
        ctx.moveTo(
          indicatorX + Math.cos(angle) * 2,
          indicatorY + Math.sin(angle) * 2
        );
        ctx.lineTo(
          indicatorX + Math.cos(angle) * 4,
          indicatorY + Math.sin(angle) * 4
        );
      }
      ctx.stroke();
    }

    // Random smoke puffs from barrel
    if (
      Math.random() < 0.02 &&
      (!this.recoilEffect || this.recoilEffect <= 0)
    ) {
      this.drawIdleSmoke(x, y, time);
    }
  }

  drawIdleSmoke(x, y, time) {
    const angle = this.rot - Math.PI / 2;
    const barrelTipX = x + Math.cos(angle) * 45;
    const barrelTipY = y + Math.sin(angle) * 45;

    for (let i = 0; i < 3; i++) {
      const offset = (Math.random() - 0.5) * 5;
      const life = 0.8 + Math.random() * 0.4;
      const size = 2 + Math.random() * 2;

      particles.push({
        x: barrelTipX + Math.cos(angle + Math.PI / 2) * offset,
        y: barrelTipY + Math.sin(angle + Math.PI / 2) * offset,
        vx: Math.cos(angle) * 20 + (Math.random() - 0.5) * 10,
        vy: Math.sin(angle) * 20 + (Math.random() - 0.5) * 10 - 10, // Rise slightly
        life,
        r: size,
        c: "#888",
        gravity: -0.1, // Negative gravity makes it rise
        fade: 0.95,
      });
    }
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\BaseTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\BaseTower.js =====

import { ctx } from "../core.js";
import { dist } from "../utils.js";
import { spawnMuzzle } from "../effects.js";
import { projectiles } from "../state.js";
import { Bullet } from "../bullet.js";
import { roundRect } from "../helpers.js";

export class BaseTower {
  constructor(gx, gy, key) {
    this.gx = gx;
    this.gy = gy;
    this.key = key;
    this.level = 1;
    this.cool = 0;
    this.rot = 0;
  }

  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      bulletSpeed: base.bulletSpeed,
      splash: base.splash || 0,
      beam: base.beam || false,
      color: base.color,
      cost: base.cost,
    };
  }

  get center() {
    return { x: this.gx * 40 + 20, y: this.gy * 40 + 20 };
  }

  upgradeCost() {
    return Math.round(this.spec().cost * (0.75 + this.level * 0.75));
  }

  sellValue() {
    return this.spec().cost * 0.7 + (this.level - 1) * this.spec().cost * 0.35;
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;
    let best = null,
      bestScore = -1;

    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);
      if (d <= s.range && e.t > bestScore) {
        best = e;
        bestScore = e.t;
      }
    }

    if (!best) return;
    const c = this.center,
      bp = best.pos;
    this.rot = Math.atan2(bp.y - c.y, bp.x - c.x);

    if (s.beam) {
      const dps = s.dmg * 60;
      if (this.cool <= 0) {
        best.damage(dps * dt);
        this.fireBeam(c, bp, s.color);
      }
      return;
    }

    if (this.cool <= 0) {
      this.cool = 1 / s.fireRate;
      this.fireProjectile(c, best, s);
    }
  }

  fireProjectile(center, target, spec) {
    projectiles.push(new Bullet(center.x, center.y, target, spec));
    spawnMuzzle(center.x, center.y, this.rot, spec.color);
  }

  fireBeam(start, end, color) {
    // This will be implemented in the LaserTower class
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    roundRect(x - 16, y - 16, 32, 32, 8, "#0e1626", true, "#223c62");

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);
    ctx.fillStyle = s.color;

    // Default single barrel
    roundRect(-8, -8, 16, 16, 4, s.color, true);

    ctx.fillStyle = "#fff";
    ctx.fillRect(0, -3, 14, 6); // muzzle indicator
    ctx.restore();

    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.fillRect(x - 10 + i * 6, y + 18, 4, 4);
    }
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\CannonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\CannonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";

export class CannonTower extends BaseTower {
  static SPEC = {
    name: "Cannon",
    cost: 120,
    range: 140,
    fireRate: 1.2,
    dmg: 55,
    splash: 60,
    bulletSpeed: 260,
    color: "#f6c66a",
  };

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    // Draw base platform
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Draw platform border
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw cannon body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Cannon base
    ctx.fillStyle = "#3a3a4a";
    ctx.fillRect(-12, -8, 24, 16);

    // Cannon barrel - main body
    const gradient = ctx.createLinearGradient(0, -10, 0, 10);
    gradient.addColorStop(0, "#8a7a6a");
    gradient.addColorStop(0.5, "#b5a892");
    gradient.addColorStop(1, "#8a7a6a");
    ctx.fillStyle = gradient;

    // Draw barrel with rounded front
    ctx.beginPath();
    ctx.roundRect(-8, -6, 30, 12, 6);
    ctx.fill();

    // Barrel rings/bands
    ctx.fillStyle = "#5a5a6a";
    ctx.fillRect(-5, -7, 3, 14);
    ctx.fillRect(5, -7, 3, 14);
    ctx.fillRect(15, -7, 3, 14);

    // Cannon muzzle
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.arc(22, 0, 6, -Math.PI / 2, Math.PI / 2);
    ctx.fill();

    // Cannon interior (dark hole)
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(24, 0, 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Draw level indicators
    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(x - 10 + i * 6, y + 18, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\DoubleCannonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\DoubleCannonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { projectiles } from "../state.js";
import { spawnMuzzle } from "../effects.js";
import { Bullet } from "../bullet.js";
import { ctx } from "../core.js";

export class DoubleCannonTower extends BaseTower {
  static SPEC = {
    name: "Double Canon",
    cost: 160,
    range: 120,
    fireRate: 0.9,
    dmg: 75,
    splash: 55,
    bulletSpeed: 240,
    color: "#f00",
  };

  fireProjectile(center, target, spec) {
    const offset = 8; // Increased offset for wider barrels
    const sin = Math.sin(this.rot);
    const cos = Math.cos(this.rot);

    // left barrel
    projectiles.push(
      new Bullet(center.x - sin * offset, center.y + cos * offset, target, spec)
    );

    // right barrel
    projectiles.push(
      new Bullet(center.x + sin * offset, center.y - cos * offset, target, spec)
    );

    spawnMuzzle(
      center.x - sin * offset,
      center.y + cos * offset,
      this.rot,
      spec.color
    );
    spawnMuzzle(
      center.x + sin * offset,
      center.y - cos * offset,
      this.rot,
      spec.color
    );
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;

    // Draw base platform
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Draw platform border
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw cannon mounting platform
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Mounting base
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.roundRect(-14, -10, 28, 20, 6);
    ctx.fill();

    // Draw two cannon barrels
    const barrelOffset = 8;

    // Left cannon
    this.drawCannonBarrel(-barrelOffset, 0, s.color);

    // Right cannon
    this.drawCannonBarrel(barrelOffset, 0, s.color);

    // Central mounting hardware
    ctx.fillStyle = "#5a5a6a";
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    // Bolts on mounting platform
    ctx.fillStyle = "#7a7a8a";
    ctx.beginPath();
    ctx.arc(-10, -6, 2, 0, Math.PI * 2);
    ctx.arc(10, -6, 2, 0, Math.PI * 2);
    ctx.arc(-10, 6, 2, 0, Math.PI * 2);
    ctx.arc(10, 6, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Draw level indicators
    for (let i = 0; i < this.level; i++) {
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(x - 12 + i * 6, y + 22, 3, 0, Math.PI * 2);
      ctx.fill();

      // Add glow effect for higher levels
      if (this.level > 2 && i >= this.level - 2) {
        ctx.fillStyle = "rgba(255, 100, 100, 0.4)";
        ctx.beginPath();
        ctx.arc(x - 12 + i * 6, y + 22, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  drawCannonBarrel(xOffset, yOffset, color) {
    // Cannon barrel - main body
    const gradient = ctx.createLinearGradient(xOffset - 5, -8, xOffset - 5, 8);
    gradient.addColorStop(0, "#9a8a7a");
    gradient.addColorStop(0.5, "#c5b8a2");
    gradient.addColorStop(1, "#9a8a7a");
    ctx.fillStyle = gradient;

    // Draw barrel with rounded front
    ctx.beginPath();
    ctx.roundRect(xOffset - 8, -5, 26, 10, 5);
    ctx.fill();

    // Barrel rings/bands
    ctx.fillStyle = "#6a6a7a";
    ctx.fillRect(xOffset - 5, -6, 3, 12);
    ctx.fillRect(xOffset + 5, -6, 3, 12);
    ctx.fillRect(xOffset + 15, -6, 3, 12);

    // Cannon muzzle
    ctx.fillStyle = "#5a5a6a";
    ctx.beginPath();
    ctx.arc(xOffset + 18, 0, 5, -Math.PI / 2, Math.PI / 2);
    ctx.fill();

    // Cannon interior (dark hole)
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(xOffset + 20, 0, 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Red accent on barrel (matching tower color)
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(xOffset - 2, 0, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\FlamethrowerTower.js =====

// ===== FILE: FlamethrowerTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnExplosion } from "../effects.js";

export class FlamethrowerTower extends BaseTower {
  static SPEC = {
    name: "Flamethrower",
    cost: 140,
    range: 80,
    fireRate: 15, // High fire rate for continuous stream
    dmg: 8,
    burnDamage: 6,
    burnDuration: 3,
    coneAngle: Math.PI / 3, // 60 degree cone
    spreadChance: 0.4,
    spreadRange: 40,
    fuelCapacity: 500,
    color: "#FF6B35",
  };

  constructor(gx, gy, key) {
    super(gx, gy, key);
    this.fuel = this.constructor.SPEC.fuelCapacity;
    this.refuelCooldown = 0;
    this.isFiring = false;
    this.fireStream = [];
    this.targetAngle = 0;
    this.flameThrowerEffect = 0;
    // ensure rot exists (BaseTower probably sets it; if not, default)
    if (this.rot === undefined) this.rot = 0;
  }

  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.4; // Higher multiplier for damage
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.1),
      fireRate: base.fireRate * 1,
      dmg: base.dmg * mult,
      burnDamage: base.burnDamage * mult,
      burnDuration: base.burnDuration * (1 + (this.level - 1) * 0.1),
      coneAngle: base.coneAngle + (this.level - 1) * 0.05, // Wider cone at higher levels
      spreadChance: base.spreadChance + (this.level - 1) * 0.05,
      spreadRange: base.spreadRange * (1 + (this.level - 1) * 0.05),
      fuelCapacity: base.fuelCapacity * (1 + (this.level - 1) * 0.2),
      color: base.color,
      cost: base.cost,
    };
  }

  // small helper to normalize angles to [-PI, PI]
  normalizeAngle(a) {
    return Math.atan2(Math.sin(a), Math.cos(a));
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;
    this.refuelCooldown -= dt;
    this.flameThrowerEffect = Math.max(0, this.flameThrowerEffect - dt * 3);

    // Refuel when not firing and cooldown is ready
    if (
      !this.isFiring &&
      this.refuelCooldown <= 0 &&
      this.fuel < s.fuelCapacity
    ) {
      this.fuel = Math.min(
        s.fuelCapacity,
        this.fuel + s.fuelCapacity * dt * 0.5
      );
    }

    // 1) Collect enemies that are within range (all directions)
    const inRange = [];
    const center = this.center;
    for (const enemy of enemiesList) {
      if (enemy.dead) continue;
      const d = dist(center, enemy.pos);
      if (d <= s.range) {
        const angle = Math.atan2(
          enemy.pos.y - center.y,
          enemy.pos.x - center.x
        );
        inRange.push({ enemy, d, angle });
      }
    }

    // 2) If any in range, pick the closest and set targetAngle to it
    if (inRange.length > 0 && this.fuel > 0) {
      inRange.sort((a, b) => a.d - b.d);
      const closest = inRange[0];
      this.targetAngle = closest.angle;

      // Smoothly rotate toward targetAngle (shortest path)
      const angleDiff = this.normalizeAngle(this.targetAngle - this.rot);
      const rotateSpeed = 5; // tweak this to rotate faster / slower
      // scale by dt, but clamp to avoid overshoot when dt large
      const step = angleDiff * Math.min(1, dt * rotateSpeed);
      this.rot = this.normalizeAngle(this.rot + step);

      // 3) Now find enemies inside the cone centered on targetAngle
      const enemiesInCone = this.getEnemiesInConeByCenter(
        enemiesList,
        s,
        this.targetAngle
      );

      if (enemiesInCone.length > 0) {
        // Fire at fireRate; continuous effect handled visually when isFiring is true
        if (this.cool <= 0) {
          this.cool = 1 / s.fireRate;
          this.fireFlame(enemiesInCone, s);
        }
        this.isFiring = true;
        // consume fuel continuously while firing
        this.fuel = Math.max(0, this.fuel - dt * 20);
        this.flameThrowerEffect = 1.0;
      } else {
        this.isFiring = false;
      }
    } else {
      this.isFiring = false;
    }

    // Update fire stream particles
    this.updateFireStream(dt);
  }

  // Checks cone centered on given centerAngle (so detection is independent of current rot)
  getEnemiesInConeByCenter(enemiesList, spec, centerAngle) {
    const enemiesInCone = [];
    const center = this.center;

    for (const enemy of enemiesList) {
      if (enemy.dead) continue;

      const d = dist(center, enemy.pos);
      if (d > spec.range) continue;

      // Calculate angle to enemy
      const angleToEnemy = Math.atan2(
        enemy.pos.y - center.y,
        enemy.pos.x - center.x
      );

      // Calculate angle difference relative to the cone center (centerAngle)
      let angleDiff = angleToEnemy - centerAngle;
      // Normalize angle difference to [-π, π]
      angleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));

      // Check if enemy is within cone
      if (Math.abs(angleDiff) <= spec.coneAngle / 2) {
        enemiesInCone.push(enemy);
      }
    }

    return enemiesInCone;
  }

  // kept your original getEnemiesInCone for compatibility if other code uses it
  getEnemiesInCone(enemiesList, spec) {
    return this.getEnemiesInConeByCenter(enemiesList, spec, this.rot);
  }

  fireFlame(enemiesInCone, spec) {
    const center = this.center;
    const fuelRatio = Math.max(0, this.fuel / spec.fuelCapacity); // 0 to 1

    // Determine damage multiplier based on fuel
    let damageMultiplier = 1;
    if (fuelRatio >= 0.5) {
      damageMultiplier = 1; // full damage
    } else if (fuelRatio > 0) {
      damageMultiplier = 0.8; // 20% reduction
    } else {
      damageMultiplier = 0.5; // 50% reduction
    }

    for (const enemy of enemiesInCone) {
      const d = dist(center, enemy.pos);
      const damageFalloff = Math.max(0.3, 1 - d / spec.range);

      const finalDamage = spec.dmg * damageFalloff * damageMultiplier;
      enemy.damage(finalDamage);

      // Burn effect can also be scaled if desired
      const burnDamage = spec.burnDamage * damageMultiplier;
      this.applyBurnEffect(enemy, { ...spec, burnDamage });

      if (Math.random() < spec.spreadChance) {
        this.spreadFire(enemy, spec);
      }
    }

    this.createFireStream(center, spec);
    this.spawnFlameParticles(center, spec);
  }

  applyBurnEffect(enemy, spec) {
    if (enemy.burning) {
      // Refresh burn duration
      enemy.burnDuration = spec.burnDuration;
      return;
    }

    enemy.burning = true;
    enemy.burnDamage = spec.burnDamage;
    enemy.burnDuration = spec.burnDuration;
    enemy.burnStartTime = performance.now();

    // Start burn damage tick
    const burnInterval = setInterval(() => {
      if (enemy.dead || !enemy.burning) {
        clearInterval(burnInterval);
        return;
      }

      const elapsed = (performance.now() - enemy.burnStartTime) / 1000;
      if (elapsed >= enemy.burnDuration) {
        enemy.burning = false;
        clearInterval(burnInterval);
        return;
      }

      // Apply burn damage
      enemy.damage(enemy.burnDamage / 2); // Damage 2 times per second
    }, 500); // Tick every 0.5 seconds
  }

  spreadFire(sourceEnemy, spec) {
    for (const e of enemies) {
      if (e.dead || e.burning || e === sourceEnemy) continue;

      const d = dist(sourceEnemy.pos, e.pos);
      if (d <= spec.spreadRange) {
        this.applyBurnEffect(e, spec);
        this.spawnSpreadFireEffect(sourceEnemy.pos, e.pos);
        break; // Only spread to one enemy at a time
      }
    }
  }

  createFireStream(center, spec) {
    // Create continuous flame stream effect
    const streamLength = spec.range;
    const particleCount = 8;

    for (let i = 0; i < particleCount; i++) {
      const distance = (i / particleCount) * streamLength;
      const spread = (spec.coneAngle / 2) * (distance / streamLength); // Cone gets wider with distance

      const angle = this.rot + (Math.random() - 0.5) * spread;
      const x = center.x + Math.cos(angle) * distance;
      const y = center.y + Math.sin(angle) * distance;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * 50 + (Math.random() - 0.5) * 30,
        vy: Math.sin(angle) * 50 + (Math.random() - 0.5) * 30,
        life: 0.3 + Math.random() * 0.2,
        r: 3 + Math.random() * 2,
        c: this.getFlameColor(),
        gravity: -0.2, // Fire rises
        fade: 0.85,
      });
    }
  }

  spawnFlameParticles(center, spec) {
    for (let i = 0; i < 12; i++) {
      const angle = this.rot + (Math.random() - 0.5) * spec.coneAngle;
      const speed = 80 + Math.random() * 60;
      const distance = Math.random() * spec.range * 0.7;

      const startX = center.x + Math.cos(angle) * distance;
      const startY = center.y + Math.sin(angle) * distance;

      particles.push({
        x: startX,
        y: startY,
        vx: Math.cos(angle) * speed * 0.5,
        vy: Math.sin(angle) * speed * 0.5,
        life: 0.4 + Math.random() * 0.3,
        r: 2 + Math.random() * 3,
        c: this.getFlameColor(),
        gravity: -0.15,
        fade: 0.9,
      });
    }
  }

  spawnSpreadFireEffect(from, to) {
    for (let i = 0; i < 6; i++) {
      const t = i / 5; // Interpolation factor
      const x = from.x + (to.x - from.x) * t;
      const y = from.y + (to.y - from.y) * t;

      particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 40,
        vy: (Math.random() - 0.5) * 40,
        life: 0.5 + Math.random() * 0.3,
        r: 2 + Math.random() * 2,
        c: this.getFlameColor(),
        gravity: -0.1,
        fade: 0.9,
      });
    }
  }

  updateFireStream(dt) {
    // Clean up old fire stream particles
    this.fireStream = this.fireStream.filter((p) => p.life > 0);
  }

  getFlameColor() {
    const colors = ["#FF6B35", "#FF8C42", "#FF4500", "#FFA500", "#FFFF00"];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw industrial base platform
    ctx.fillStyle = "#2a1a1a";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Heat glow effect when firing
    if (this.flameThrowerEffect > 0) {
      const intensity = this.flameThrowerEffect;
      const gradient = ctx.createRadialGradient(x, y, 10, x, y, 30);
      gradient.addColorStop(0, `rgba(255, 107, 53, ${0.6 * intensity})`);
      gradient.addColorStop(1, "rgba(255, 107, 53, 0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, 30, 0, Math.PI * 2);
      ctx.fill();
    }

    // Platform border
    ctx.strokeStyle = "#4d3d3d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw flamethrower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main body - industrial tank design
    ctx.fillStyle = "#3a3a4a";
    ctx.beginPath();
    ctx.roundRect(-14, -12, 28, 24, 6);
    ctx.fill();

    // Fuel tank
    ctx.fillStyle = "#2a2a3a";
    ctx.beginPath();
    ctx.roundRect(-12, -10, 24, 20, 4);
    ctx.fill();

    // Fuel level indicator
    const fuelLevel = this.fuel / s.fuelCapacity;
    ctx.fillStyle =
      fuelLevel > 0.5 ? "#4CAF50" : fuelLevel > 0.25 ? "#FFC107" : "#F44336";
    ctx.beginPath();
    ctx.roundRect(-10, 8 - fuelLevel * 16, 20, fuelLevel * 16, 2);
    ctx.fill();

    // Tank details
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 1.5;
    for (let i = -6; i <= 6; i += 4) {
      ctx.beginPath();
      ctx.arc(0, i, 8, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Flamethrower nozzle
    ctx.fillStyle = "#4a4a5a";
    ctx.beginPath();
    ctx.roundRect(8, -6, 14, 12, 3);
    ctx.fill();

    // Nozzle tip
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.ellipse(22, 0, 3, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Pilot light (always on)
    ctx.fillStyle = "#0066FF";
    ctx.beginPath();
    ctx.arc(20, -8, 2, 0, Math.PI * 2);
    ctx.fill();

    // Fuel lines
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-8, 8);
    ctx.lineTo(8, 4);
    ctx.lineTo(16, 0);
    ctx.stroke();

    // Pressure gauges
    ctx.strokeStyle = "#777";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(-8, -6, 3, 0, Math.PI * 2);
    ctx.arc(8, -8, 3, 0, Math.PI * 2);
    ctx.stroke();

    // Gauge needles
    ctx.strokeStyle = "#FF0000";
    ctx.lineWidth = 1.5;
    const gaugeAngle = time * 3 + Math.sin(time * 5) * 0.5;
    ctx.beginPath();
    ctx.moveTo(-8, -6);
    ctx.lineTo(-8 + Math.cos(gaugeAngle) * 2, -6 + Math.sin(gaugeAngle) * 2);
    ctx.stroke();

    // Warning labels
    ctx.fillStyle = "#FFEB3B";
    ctx.fillRect(-6, 2, 3, 2);
    ctx.fillRect(4, -2, 3, 2);

    // Ignition system
    if (this.isFiring) {
      // Show active flame at nozzle
      ctx.fillStyle = this.getFlameColor();
      ctx.beginPath();
      ctx.ellipse(24, 0, 4, 2, 0, 0, Math.PI * 2);
      ctx.fill();

      // Flame stream
      for (let i = 1; i <= 5; i++) {
        const flameX = 24 + i * 8;
        const flameSize = 6 - i;
        const flameSpread = i * 2;

        ctx.fillStyle = this.getFlameColor();
        ctx.globalAlpha = 0.7 - i * 0.1;
        ctx.beginPath();
        ctx.ellipse(flameX, 0, flameSize, flameSpread, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    // Draw level indicators as fuel canisters
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;

      // Canister
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.roundRect(indicatorX - 2, indicatorY - 4, 4, 8, 1);
      ctx.fill();

      // Canister top
      ctx.fillStyle = "#888";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY - 4, 2, 0, Math.PI * 2);
      ctx.fill();

      // Flame effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawMiniFlame(indicatorX, indicatorY - 6, time);
      }
    }

    // Draw fuel meter
    this.drawFuelMeter(x, y - 30, s);

    // Heat shimmer effect when firing
    if (this.isFiring && Math.random() < 0.3) {
      this.drawHeatShimmer(x, y, time);
    }
  }

  drawFuelMeter(x, y, spec) {
    const fuelPercent = this.fuel / spec.fuelCapacity;
    const meterWidth = 30;
    const meterHeight = 4;

    // Meter background
    ctx.fillStyle = "#333";
    ctx.fillRect(x - meterWidth / 2, y, meterWidth, meterHeight);

    // Fuel level
    const fuelColor =
      fuelPercent > 0.5
        ? "#4CAF50"
        : fuelPercent > 0.25
        ? "#FFC107"
        : "#F44336";
    ctx.fillStyle = fuelColor;
    ctx.fillRect(x - meterWidth / 2, y, meterWidth * fuelPercent, meterHeight);

    // Meter border
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 1;
    ctx.strokeRect(x - meterWidth / 2, y, meterWidth, meterHeight);
  }

  drawMiniFlame(x, y, time) {
    const flameHeight = 3 + Math.sin(time * 10) * 1;

    ctx.fillStyle = "#FF6B35";
    ctx.beginPath();
    ctx.ellipse(x, y, 1.5, flameHeight, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#FFFF00";
    ctx.beginPath();
    ctx.ellipse(
      x,
      y + flameHeight * 0.3,
      0.8,
      flameHeight * 0.6,
      0,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  drawHeatShimmer(x, y, time) {
    ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
    ctx.lineWidth = 1;

    for (let i = 0; i < 3; i++) {
      const shimmerX = x + (Math.random() - 0.5) * 40;
      const shimmerY = y - 10 - i * 8;
      const wave = Math.sin(time * 15 + i) * 3;

      ctx.beginPath();
      ctx.moveTo(shimmerX, shimmerY);
      ctx.quadraticCurveTo(
        shimmerX + wave,
        shimmerY - 8,
        shimmerX,
        shimmerY - 16
      );
      ctx.stroke();
    }
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\GunTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\GunTower.js =====

import { BaseTower } from "./BaseTower.js";

export class GunTower extends BaseTower {
  static SPEC = {
    name: "Gunner",
    cost: 80,
    range: 120,
    fireRate: 6,
    dmg: 12,
    bulletSpeed: 340,
    color: "#6cf",
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\IceTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\IceTower.js =====

import { BaseTower } from "./BaseTower.js";
import { projectiles } from "../state.js";
import { spawnMuzzle } from "../effects.js";
import { Bullet } from "../bullet.js";
import { ctx } from "../core.js";

export class IceTower extends BaseTower {
  static SPEC = {
    name: "Ice Tower",
    cost: 180,
    range: 130,
    fireRate: 2.5,
    dmg: 8,
    slowAmount: 0.6,
    slowDuration: 3,
    freezeChance: 0.2,
    bulletSpeed: 300,
    color: "#6cfaff",
  };

  // Override spec to include ice properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      slowAmount: base.slowAmount,
      slowDuration: base.slowDuration * (1 + (this.level - 1) * 0.1),
      freezeChance: base.freezeChance + (this.level - 1) * 0.05,
      bulletSpeed: base.bulletSpeed,
      color: base.color,
      cost: base.cost,
    };
  }

  fireProjectile(center, target, spec) {
    // Create ice projectile with special properties
    const iceBullet = new Bullet(center.x, center.y, target, spec);

    // Add ice-specific properties to the bullet
    iceBullet.isIce = true;
    iceBullet.slowAmount = spec.slowAmount;
    iceBullet.slowDuration = spec.slowDuration;
    iceBullet.freezeChance = spec.freezeChance;

    projectiles.push(iceBullet);
    spawnMuzzle(center.x, center.y, this.rot, spec.color);

    // Add frost particles effect
    this.spawnFrostParticles(center.x, center.y);
  }

  spawnFrostParticles(x, y) {
    for (let i = 0; i < 5; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 30 + Math.random() * 50;
      const size = 2 + Math.random() * 3;

      // Add to particles array (you might need to import it)
      const particles = window.particles || [];
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 0.5 + Math.random() * 0.3,
        r: size,
        c: "#a0f0ff",
        gravity: 0.2,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw icy base platform
    ctx.fillStyle = "#0e1a2a";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Icy glow effect
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 22);
    gradient.addColorStop(0, "rgba(108, 250, 255, 0.4)");
    gradient.addColorStop(1, "rgba(108, 250, 255, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Icy platform border
    ctx.strokeStyle = "#2a5a7a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw tower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main icy structure
    ctx.fillStyle = "#a0e0f0";
    ctx.beginPath();
    ctx.roundRect(-10, -10, 20, 20, 6);
    ctx.fill();

    // Ice crystal details
    ctx.fillStyle = "#d0f8ff";
    this.drawIceCrystal(-5, -5, 4, time);
    this.drawIceCrystal(5, -5, 3, time);
    this.drawIceCrystal(0, 5, 5, time);

    // Frost emitter (main crystal)
    const pulse = Math.sin(time * 3) * 1.5;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(12, 0, 4 + pulse, 0, Math.PI * 2);
    ctx.fill();

    // Inner crystal glow
    ctx.fillStyle = "rgba(176, 240, 255, 0.7)";
    ctx.beginPath();
    ctx.arc(12, 0, 2 + pulse * 0.5, 0, Math.PI * 2);
    ctx.fill();

    // Frost patterns on body
    ctx.strokeStyle = "rgba(200, 240, 255, 0.6)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-8, 2);
    ctx.lineTo(-2, -2);
    ctx.lineTo(2, 3);
    ctx.lineTo(6, -1);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as ice shards
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;

      // Glow effect
      ctx.fillStyle = "rgba(108, 250, 255, 0.3)";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 4, 0, Math.PI * 2);
      ctx.fill();

      // Ice shard
      ctx.fillStyle = s.color;
      this.drawIceShard(indicatorX, indicatorY, 3);

      // Frost effect for higher levels
      if (this.level > 2 && i >= this.level - 2) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Occasional snowflake particles
    if (Math.random() < 0.05) {
      this.drawSnowflake(x, y, time);
    }
  }

  drawIceCrystal(x, y, size, time) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(time);

    ctx.beginPath();
    ctx.moveTo(0, -size);
    ctx.lineTo(size * 0.7, 0);
    ctx.lineTo(0, size);
    ctx.lineTo(-size * 0.7, 0);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  drawIceShard(x, y, size) {
    ctx.beginPath();
    ctx.moveTo(x, y - size);
    ctx.lineTo(x + size * 0.7, y);
    ctx.lineTo(x, y + size);
    ctx.lineTo(x - size * 0.7, y);
    ctx.closePath();
    ctx.fill();
  }

  drawSnowflake(x, y, time) {
    const flakeX = x + (Math.random() - 0.5) * 30;
    const flakeY = y + (Math.random() - 0.5) * 30 - 20;
    const size = 1 + Math.random() * 2;

    ctx.save();
    ctx.translate(flakeX, flakeY);
    ctx.rotate(time);

    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
    ctx.lineWidth = 1;

    for (let i = 0; i < 6; i++) {
      ctx.rotate(Math.PI / 3);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(size * 2, 0);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(size * 0.7, -size * 0.7);
      ctx.lineTo(size * 0.7, size * 0.7);
      ctx.stroke();
    }

    ctx.restore();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\LaserTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\LaserTower.js =====

import { BaseTower } from "./BaseTower.js";
import { spawnBeam } from "../effects.js";
import { ctx } from "../core.js";

export class LaserTower extends BaseTower {
  static SPEC = {
    name: "Laser",
    cost: 250,
    range: 150,
    fireRate: 12,
    dmg: 5,
    beam: true,
    color: "#ff69e0",
  };

  fireBeam(start, end, color) {
    spawnBeam(start, end, color);
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw high-tech base platform with glow
    ctx.fillStyle = "#0e1626";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Platform glow effect
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 22);
    gradient.addColorStop(0, "rgba(255, 105, 224, 0.3)");
    gradient.addColorStop(1, "rgba(255, 105, 224, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with energy effect
    ctx.strokeStyle = "#223c62";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw tower body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main housing - futuristic design
    ctx.fillStyle = "#2a2a3a";
    ctx.beginPath();
    ctx.roundRect(-10, -12, 20, 24, 8);
    ctx.fill();

    // Energy core housing
    ctx.fillStyle = "#1a1a2a";
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fill();

    // Pulsing energy core
    const pulseSize = 6 + Math.sin(time * 5) * 1.5;
    const coreAlpha = 0.7 + Math.sin(time * 3) * 0.3;

    ctx.fillStyle = `rgba(255, 220, 255, ${coreAlpha})`;
    ctx.beginPath();
    ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "rgba(255, 105, 224, 0.6)";
    ctx.beginPath();
    ctx.arc(0, 0, pulseSize * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // Laser emitter array
    ctx.fillStyle = "#4a4a6a";
    ctx.beginPath();
    ctx.roundRect(8, -8, 16, 16, 4);
    ctx.fill();

    // Laser lenses
    ctx.fillStyle = "#a0a0ff";
    ctx.beginPath();
    ctx.arc(16, -4, 3, 0, Math.PI * 2);
    ctx.arc(16, 0, 3, 0, Math.PI * 2);
    ctx.arc(16, 4, 3, 0, Math.PI * 2);
    ctx.fill();

    // Main laser lens (center)
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(16, 0, 4, 0, Math.PI * 2);
    ctx.fill();

    // Energy conduits
    ctx.strokeStyle = "#ff69e0";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-6, -6);
    ctx.lineTo(6, -6);
    ctx.lineTo(10, -2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-6, 6);
    ctx.lineTo(6, 6);
    ctx.lineTo(10, 2);
    ctx.stroke();

    // Cooling fins/heat sinks
    ctx.fillStyle = "#3a3a5a";
    for (let i = -10; i <= 10; i += 5) {
      ctx.fillRect(-12, i, 4, 2);
    }

    ctx.restore();

    // Draw level indicators with glow effect
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;

      // Glow effect
      ctx.fillStyle = "rgba(255, 105, 224, 0.3)";
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Main indicator
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Pulsing effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        const pulse = Math.sin(time * 4) * 2;
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath();
        ctx.arc(indicatorX, indicatorY, 3 + pulse, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Add some particle effects around the tower
    if (Math.random() < 0.1) {
      this.drawEnergyParticle(x, y, time);
    }
  }

  drawEnergyParticle(x, y, time) {
    const angle = Math.random() * Math.PI * 2;
    const distance = 15 + Math.random() * 10;
    const size = 1 + Math.random() * 2;

    const particleX = x + Math.cos(angle) * distance;
    const particleY = y + Math.sin(angle) * distance;

    ctx.fillStyle = `rgba(180, 100, 255, ${0.3 + Math.sin(time * 10) * 0.2})`;
    ctx.beginPath();
    ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Add roundRect method to CanvasRenderingContext2D if it doesn't exist
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (
    x,
    y,
    width,
    height,
    radius
  ) {
    if (width < 2 * radius) radius = width / 2;
    if (height < 2 * radius) radius = height / 2;

    this.beginPath();
    this.moveTo(x + radius, y);
    this.arcTo(x + width, y, x + width, y + height, radius);
    this.arcTo(x + width, y + height, x, y + height, radius);
    this.arcTo(x, y + height, x, y, radius);
    this.arcTo(x, y, x + width, y, radius);
    this.closePath();
    return this;
  };
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\MissileTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\MissileTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, projectiles, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnExplosion, spawnMuzzle } from "../effects.js";
import { Missile } from "../missile.js"; // We'll create this special projectile

export class MissileTower extends BaseTower {
  static SPEC = {
    name: "Missile Tower",
    cost: 280,
    range: 160,
    fireRate: 0.8,
    dmg: 70,
    splash: 80,
    bulletSpeed: 180,
    homingStrength: 0.1,
    retarget: true,
    color: "#FF5722",
  };

  // Override spec to include missile properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.4; // Higher multiplier for damage
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.1), // Better range scaling
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      splash: base.splash * (1 + (this.level - 1) * 0.08),
      bulletSpeed: base.bulletSpeed,
      homingStrength: base.homingStrength + (this.level - 1) * 0.02,
      retarget: base.retarget,
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    // pick best target as before
    let best = null;
    let bestScore = -1;
    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);
      if (d <= s.range && e.t > bestScore) {
        best = e;
        bestScore = e.t;
      }
    }

    // If we found a best right now => lock onto it
    if (best) {
      this.lockedTarget = best;
      this.lockTimer = this.LOCK_HOLD;
    } else {
      // If no immediate best, but we have a locked target, keep it for a short time
      if (this.lockedTarget && !this.lockedTarget.dead) {
        const d = dist(this.center, this.lockedTarget.pos);
        if (d <= s.range && this.lockTimer > 0) {
          this.lockTimer -= dt;
          best = this.lockedTarget; // keep aiming at the locked target
        } else {
          // lock expired or target out of range -> clear lock
          this.lockedTarget = null;
          this.lockTimer = 0;
        }
      } else {
        // no locked target, ensure timer cleared
        this.lockTimer = 0;
        this.lockedTarget = null;
      }
    }

    // Only rotate if we have a target (either new best or locked one)
    // Only rotate if we have a target (either new best or locked one)
    if (best) {
      // local coordinates of the missile nose (must match drawMissileInSilo & fireMissile)
      const localX = 0;
      const localY = -30;

      // Include recoil translation used in draw() (translate(0, this.recoilEffect * 2) before rotate)
      const recoilLocal =
        this.recoilEffect && this.recoilEffect > 0 ? this.recoilEffect * 2 : 0;
      const localYWithRecoil = localY + recoilLocal;

      // If target sits exactly at tower centre, do nothing
      if (!(best.pos.x === this.center.x && best.pos.y === this.center.y)) {
        // Start with a reasonable guess (center -> target) but add PI/2 because nose points -Y
        let rotGuess =
          Math.atan2(best.pos.y - this.center.y, best.pos.x - this.center.x) +
          Math.PI / 2;

        // Iterate: compute nose world position for rotGuess, then compute angle from that nose to the target,
        // then add PI/2 to get the rotation that orients the launcher so the nose faces the target.
        for (let i = 0; i < 4; i++) {
          const sx =
            this.center.x +
            Math.cos(rotGuess) * localX -
            Math.sin(rotGuess) * localYWithRecoil;
          const sy =
            this.center.y +
            Math.sin(rotGuess) * localX +
            Math.cos(rotGuess) * localYWithRecoil;

          // angle from nose (sx,sy) to target, then +PI/2 to convert to launcher rotation
          rotGuess = Math.atan2(best.pos.y - sy, best.pos.x - sx) + Math.PI / 2;
        }

        // instant set — or lerp for smooth turning (see notes)
        this.rot = rotGuess;
      }
    }

    // Fire if cooldown is ready and there's a target
    if (this.cool <= 0 && best) {
      this.cool = 1 / s.fireRate;
      this.fireMissile(best, s);

      // keep locked target after firing so it doesn't snap away
      this.lockedTarget = best;
      this.lockTimer = this.LOCK_HOLD;
    }
  }

  fireMissile(target, spec) {
    const c = this.center;

    // Local coordinates of the missile nose in the launcher space
    // (matches drawMissileInSilo: nose cone goes up to about -30)
    const localX = 0;
    const localY = -30;

    // Transform local -> world using rotation matrix (rotate, then translate)
    const startX =
      c.x + Math.cos(this.rot) * localX - Math.sin(this.rot) * localY;
    const startY =
      c.y + Math.sin(this.rot) * localX + Math.cos(this.rot) * localY;

    // Compute initial rotation based on spawn position toward the target
    const initialRot = Math.atan2(target.pos.y - startY, target.pos.x - startX);

    // Create homing missile at the correct position — pass initial rotation
    const missile = new Missile(startX, startY, target, spec, initialRot);
    projectiles.push(missile);

    // Muzzle flash and smoke at the launch position
    spawnMuzzle(startX, startY, initialRot, spec.color);
    this.spawnLaunchSmoke(startX, startY);

    // Tower recoil effect
    this.recoilEffect = 0.3;
  }

  spawnLaunchSmoke(x, y) {
    for (let i = 0; i < 12; i++) {
      const angle = this.rot + Math.PI + (Math.random() - 0.5) * 0.5;
      const speed = 60 + Math.random() * 60;
      const size = 3 + Math.random() * 3;
      const life = 1 + Math.random() * 0.5;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#888888",
        gravity: 0.1,
        fade: 0.92,
        shrink: 0.95,
      });
    }

    // Add some forward thrust particles too
    for (let i = 0; i < 6; i++) {
      const angle = this.rot + (Math.random() - 0.5) * 0.2;
      const speed = 100 + Math.random() * 100;
      const size = 2 + Math.random() * 2;
      const life = 0.5 + Math.random() * 0.3;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#FF5722",
        gravity: 0.05,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw missile base platform
    ctx.fillStyle = "#261a1a";
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.fill();

    // Rocket launch pad glow
    const pulse = Math.sin(time * 4) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 12, x, y, 28);
    gradient.addColorStop(0, `rgba(255, 87, 34, ${0.6 * pulse})`);
    gradient.addColorStop(1, "rgba(255, 87, 34, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 28, 0, Math.PI * 2);
    ctx.fill();

    // Platform border
    ctx.strokeStyle = "#4d2d2d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 22, 0, Math.PI * 2);
    ctx.stroke();

    // Draw missile launcher
    ctx.save();
    ctx.translate(x, y);

    // Apply recoil effect if recently fired
    if (this.recoilEffect > 0) {
      ctx.translate(0, this.recoilEffect * 2);
      this.recoilEffect -= 0.05;
    }

    ctx.rotate(this.rot);

    // Launcher base
    ctx.fillStyle = "#3d2d2d";
    ctx.beginPath();
    ctx.roundRect(-14, -10, 28, 20, 5);
    ctx.fill();

    // Launch rails
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-8, -15);
    ctx.lineTo(-8, 15);
    ctx.moveTo(8, -15);
    ctx.lineTo(8, 15);
    ctx.stroke();

    // Missile silo (if no recent fire)
    if (!this.recoilEffect || this.recoilEffect <= 0) {
      this.drawMissileInSilo();
    }

    // Targeting system
    ctx.fillStyle = "#2196F3";
    ctx.beginPath();
    ctx.arc(0, 0, 6, 0, Math.PI * 2);
    ctx.fill();

    // Targeting reticle
    ctx.strokeStyle = "#2196F3";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, Math.PI * 2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(-8, 0);
    ctx.lineTo(8, 0);
    ctx.moveTo(0, -8);
    ctx.lineTo(0, 8);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as missile icons
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;

      // Missile icon
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.moveTo(indicatorX - 2, indicatorY - 4);
      ctx.lineTo(indicatorX + 2, indicatorY - 4);
      ctx.lineTo(indicatorX + 2, indicatorY + 4);
      ctx.lineTo(indicatorX - 2, indicatorY + 4);
      ctx.closePath();
      ctx.fill();

      // Missile tip
      ctx.beginPath();
      ctx.moveTo(indicatorX + 2, indicatorY);
      ctx.lineTo(indicatorX + 4, indicatorY);
      ctx.lineTo(indicatorX + 2, indicatorY - 2);
      ctx.closePath();
      ctx.fill();

      // Fire effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawMiniExhaust(indicatorX, indicatorY, time);
      }
    }

    // Random targeting laser effect
    if (Math.random() < 0.05) {
      this.drawTargetingLaser(x, y, time);
    }
  }

  drawMissileInSilo() {
    // Missile body - positioned to fire forward
    ctx.fillStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.roundRect(-4, -24, 8, 24, 3); // Moved forward (negative Y)
    ctx.fill();

    // Missile stripes
    ctx.fillStyle = "#FF5722";
    ctx.fillRect(-4, -16, 8, 3); // Adjusted positions
    ctx.fillRect(-4, -9, 8, 3); // Adjusted positions

    // Missile nose cone - pointing forward
    ctx.fillStyle = "#FF5722";
    ctx.beginPath();
    ctx.moveTo(-4, -24);
    ctx.lineTo(4, -24);
    ctx.lineTo(0, -30); // Pointing forward (negative Y)
    ctx.closePath();
    ctx.fill();

    // Fins - adjusted position
    ctx.fillStyle = "#FF5722";
    ctx.beginPath();
    ctx.moveTo(-4, -2); // Adjusted position
    ctx.lineTo(-8, -2); // Adjusted position
    ctx.lineTo(-4, 2); // Adjusted position
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(4, -2); // Adjusted position
    ctx.lineTo(8, -2); // Adjusted position
    ctx.lineTo(4, 2); // Adjusted position
    ctx.closePath();
    ctx.fill();
  }

  drawMiniExhaust(x, y, time) {
    const pulse = Math.sin(time * 8) * 0.5 + 1;

    ctx.fillStyle = `rgba(255, 87, 34, ${0.8 * pulse})`;
    ctx.beginPath();
    ctx.arc(x - 4, y, 2 * pulse, 0, Math.PI * 2);
    ctx.fill();
  }

  drawTargetingLaser(x, y, time) {
    const angle = this.rot + (Math.random() - 0.5) * 0.2;
    const length = 30 + Math.random() * 20;

    ctx.strokeStyle = `rgba(33, 150, 243, ${0.6 + Math.sin(time * 10) * 0.4})`;
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 2]);
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
    ctx.stroke();
    ctx.setLineDash([]);
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\PoisonTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\PoisonTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnPoisonCloud } from "../effects.js";

export class PoisonTower extends BaseTower {
  static SPEC = {
    name: "Poison Tower",
    cost: 190,
    range: 110,
    fireRate: 1.5,
    dmg: 15,
    dotDamage: 8,
    dotDuration: 4,
    spreadRange: 60,
    cloudDuration: 3,
    color: "#4CAF50",
  };

  // Override spec to include poison properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      dotDamage: base.dotDamage * mult,
      dotDuration: base.dotDuration * (1 + (this.level - 1) * 0.1),
      spreadRange: base.spreadRange * (1 + (this.level - 1) * 0.05),
      cloudDuration: base.cloudDuration * (1 + (this.level - 1) * 0.1),
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    if (this.cool <= 0) {
      let best = null;
      let bestScore = -1;

      for (const e of enemiesList) {
        if (e.dead || e.poisoned) continue; // Don't target already poisoned enemies
        const p = e.pos;
        const d = dist(this.center, p);
        if (d <= s.range && e.t > bestScore) {
          best = e;
          bestScore = e.t;
        }
      }

      if (best) {
        this.cool = 1 / s.fireRate;
        this.rot = Math.atan2(
          best.pos.y - this.center.y,
          best.pos.x - this.center.x
        );
        this.firePoison(best, s);
      }
    }
  }

  firePoison(target, spec) {
    const c = this.center;

    // Initial damage
    target.damage(spec.dmg);

    // Apply poison effect
    this.applyPoisonEffect(target, spec);

    // Create poison cloud at target location
    spawnPoisonCloud(
      target.pos.x,
      target.pos.y,
      spec.cloudDuration,
      spec.spreadRange
    );

    // Visual effects
    this.spawnPoisonParticles(c.x, c.y, target.pos.x, target.pos.y);
    this.spawnDrippingEffect(c.x, c.y);
  }

  applyPoisonEffect(enemy, spec) {
    if (enemy.poisoned) return; // Already poisoned

    enemy.poisoned = true;
    enemy.poisonDamage = spec.dotDamage;
    enemy.poisonDuration = spec.dotDuration;
    enemy.poisonStartTime = performance.now();

    // Start poison damage tick
    const poisonInterval = setInterval(() => {
      if (enemy.dead || !enemy.poisoned) {
        clearInterval(poisonInterval);
        return;
      }

      const elapsed = (performance.now() - enemy.poisonStartTime) / 1000;
      if (elapsed >= enemy.poisonDuration) {
        enemy.poisoned = false;
        clearInterval(poisonInterval);
        return;
      }

      // Apply damage
      enemy.damage(enemy.poisonDamage / 4); // Damage 4 times per second

      // Chance to spread to nearby enemies
      if (Math.random() < 0.2) {
        // 20% chance per tick to spread
        this.spreadPoison(enemy, spec);
      }
    }, 250); // Tick 4 times per second
  }

  spreadPoison(sourceEnemy, spec) {
    for (const e of enemies) {
      if (e.dead || e.poisoned || e === sourceEnemy) continue;

      const d = dist(sourceEnemy.pos, e.pos);
      if (d <= spec.spreadRange) {
        this.applyPoisonEffect(e, spec);
        spawnPoisonCloud(
          e.pos.x,
          e.pos.y,
          spec.cloudDuration / 2,
          spec.spreadRange / 2
        );
        break; // Only spread to one enemy at a time
      }
    }
  }

  spawnPoisonParticles(startX, startY, endX, endY) {
    for (let i = 0; i < 6; i++) {
      const angle = Math.atan2(endY - startY, endX - startX);
      const spread = (Math.random() - 0.5) * 0.5;
      const speed = 120 + Math.random() * 80;
      const size = 2 + Math.random() * 2;
      const life = 0.8 + Math.random() * 0.4;

      particles.push({
        x: startX,
        y: startY,
        vx: Math.cos(angle + spread) * speed,
        vy: Math.sin(angle + spread) * speed,
        life,
        r: size,
        c: "#4CAF50",
        gravity: 0.3,
        fade: 0.9,
      });
    }
  }

  spawnDrippingEffect(x, y) {
    // Create dripping poison effect from tower
    for (let i = 0; i < 3; i++) {
      const angle = Math.random() * Math.PI - Math.PI / 2; // Mostly downward
      const speed = 40 + Math.random() * 30;
      const size = 1.5 + Math.random() * 1.5;
      const life = 1 + Math.random() * 0.5;

      particles.push({
        x: x + (Math.random() - 0.5) * 10,
        y: y + 15,
        vx: Math.cos(angle) * speed * 0.3,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#388E3C",
        gravity: 0.5,
        fade: 0.95,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw toxic base platform
    ctx.fillStyle = "#1a261a";
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.fill();

    // Toxic glow effect
    const pulse = Math.sin(time * 3) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 10, x, y, 25);
    gradient.addColorStop(0, `rgba(76, 175, 80, ${0.5 * pulse})`);
    gradient.addColorStop(1, "rgba(76, 175, 80, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with toxic effect
    ctx.strokeStyle = "#2d4d2d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 18, 0, Math.PI * 2);
    ctx.stroke();

    // Draw toxic container body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main toxic container
    ctx.fillStyle = "#2d4d2d";
    ctx.beginPath();
    ctx.roundRect(-12, -12, 24, 24, 6);
    ctx.fill();

    // Toxic liquid level (animated)
    const liquidLevel = 0.6 + Math.sin(time * 2) * 0.1;
    ctx.fillStyle = "#4CAF50";
    ctx.beginPath();
    ctx.roundRect(-10, 10 - liquidLevel * 20, 20, liquidLevel * 20, 4);
    ctx.fill();

    // Container details
    ctx.strokeStyle = "#388E3C";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(-12, -12, 24, 24, 6);
    ctx.stroke();

    // Toxic emitter nozzle
    ctx.fillStyle = "#3d6d3d";
    ctx.beginPath();
    ctx.roundRect(8, -6, 12, 12, 3);
    ctx.fill();

    // Nozzle opening
    ctx.fillStyle = "#1a261a";
    ctx.beginPath();
    ctx.roundRect(16, -4, 4, 8, 1);
    ctx.fill();

    // Bubbles in toxic liquid
    ctx.fillStyle = "#A5D6A7";
    for (let i = 0; i < 3; i++) {
      const bubbleX = -8 + Math.random() * 16;
      const bubbleY = -5 + Math.random() * 10;
      const bubbleSize = 1 + Math.random() * 2;
      const bubblePulse = Math.sin(time * 3 + i) * 0.3 + 1;

      ctx.beginPath();
      ctx.arc(bubbleX, bubbleY, bubbleSize * bubblePulse, 0, Math.PI * 2);
      ctx.fill();
    }

    // Hazard symbols
    ctx.strokeStyle = "#FFEB3B";
    ctx.lineWidth = 2;
    ctx.beginPath();
    // Skull shape
    ctx.arc(0, -5, 4, 0, Math.PI * 2);
    ctx.moveTo(-3, 0);
    ctx.lineTo(3, 0);
    ctx.moveTo(-4, 2);
    ctx.lineTo(4, 2);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as toxic bubbles
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 10 + i * 6;
      const indicatorY = y + 22;
      const bubblePulse = Math.sin(time * 4 + i) * 0.5 + 1;

      // Bubble glow
      ctx.fillStyle = `rgba(76, 175, 80, ${0.4 * bubblePulse})`;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5 * bubblePulse, 0, Math.PI * 2);
      ctx.fill();

      // Main bubble
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Bubble highlight
      ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
      ctx.beginPath();
      ctx.arc(indicatorX - 1, indicatorY - 1, 1, 0, Math.PI * 2);
      ctx.fill();
    }

    // Occasional toxic bubbles rising from tower
    if (Math.random() < 0.1) {
      this.drawRisingBubble(x, y, time);
    }

    // Toxic dripping from nozzle
    if (Math.random() < 0.3) {
      this.drawToxicDrip(x, y, time);
    }
  }

  drawRisingBubble(x, y, time) {
    const bubbleX = x + (Math.random() - 0.5) * 15;
    const bubbleY = y - 20 - Math.random() * 10;
    const size = 1.5 + Math.random() * 1.5;

    ctx.fillStyle = "rgba(165, 214, 167, 0.8)";
    ctx.beginPath();
    ctx.arc(bubbleX, bubbleY, size, 0, Math.PI * 2);
    ctx.fill();

    // Bubble highlight
    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
    ctx.beginPath();
    ctx.arc(
      bubbleX - size * 0.3,
      bubbleY - size * 0.3,
      size * 0.4,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }

  drawToxicDrip(x, y, time) {
    const dripX = x + 18 + (Math.random() - 0.5) * 2;
    const dripLength = 3 + Math.random() * 4;

    ctx.strokeStyle = "#388E3C";
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(dripX, y - 5);
    ctx.lineTo(dripX, y - 5 - dripLength);
    ctx.stroke();

    // Drip end
    ctx.fillStyle = "#388E3C";
    ctx.beginPath();
    ctx.arc(dripX, y - 5 - dripLength, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\SniperTower.js =====

// ===== FILE: src/towers/SniperTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies, projectiles, particles } from "../state.js";
import { dist } from "../utils.js";
import { spawnMuzzle, spawnHit } from "../effects.js";
import { SniperBullet } from "../sniperBullet.js"; // We'll create this special projectile

export class SniperTower extends BaseTower {
  static SPEC = {
    name: "Sniper Tower",
    cost: 350,
    range: 400, // Very long range
    fireRate: 0.3, // Slow fire rate
    dmg: 200, // High damage
    bulletSpeed: 1200, // Very fast bullet
    penetration: 2, // Can penetrate through multiple enemies
    critChance: 0.25, // Chance for critical hit
    critMultiplier: 2.5, // Damage multiplier for critical hits
    color: "#2b4162",
  };

  // Override spec to include sniper properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.5; // Higher multiplier for damage
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.15), // Better range scaling
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.1),
      dmg: base.dmg * mult,
      bulletSpeed: base.bulletSpeed,
      penetration: base.penetration + Math.floor((this.level - 1) / 2), // Increase penetration every 2 levels
      critChance: base.critChance + (this.level - 1) * 0.05,
      critMultiplier: base.critMultiplier + (this.level - 1) * 0.1,
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    // Sniper tower prioritizes high-value targets (farthest along the path)
    let best = null;
    let bestScore = -1;
    for (const e of enemiesList) {
      if (e.dead) continue;
      const p = e.pos;
      const d = dist(this.center, p);
      if (d <= s.range && e.t > bestScore) {
        best = e;
        bestScore = e.t;
      }
    }

    // If we found a target, aim at it
    if (best) {
      const dx = best.pos.x - this.center.x;
      const dy = best.pos.y - this.center.y;
      this.rot = Math.atan2(dy, dx) + Math.PI / 2;
    }

    // Fire if cooldown is ready and there's a target
    if (this.cool <= 0 && best) {
      this.cool = 1 / s.fireRate;
      this.fireSniperShot(best, s);
    }
  }

  fireSniperShot(target, spec) {
    const c = this.center;

    // Calculate starting position at the tip of the sniper barrel
    const barrelLength = 35;
    const startX = c.x + Math.cos(this.rot - Math.PI / 2) * barrelLength;
    const startY = c.y + Math.sin(this.rot - Math.PI / 2) * barrelLength;

    // Create sniper bullet
    const bullet = new SniperBullet(
      startX,
      startY,
      this.rot - Math.PI / 2, // Adjust rotation to point forward
      spec
    );
    projectiles.push(bullet);

    // Muzzle flash and smoke
    spawnMuzzle(startX, startY, this.rot - Math.PI / 2, spec.color);
    this.spawnSniperSmoke(startX, startY);

    // Sniper laser sight effect
    this.drawLaserSight(target);
  }

  spawnSniperSmoke(x, y) {
    for (let i = 0; i < 8; i++) {
      const angle = this.rot - Math.PI / 2 + (Math.random() - 0.5) * 0.3;
      const speed = 40 + Math.random() * 40;
      const size = 2 + Math.random() * 2;
      const life = 0.8 + Math.random() * 0.4;

      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#888888",
        gravity: 0.05,
        fade: 0.93,
        shrink: 0.97,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw sniper tower base
    ctx.fillStyle = "#1a1a2e";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Platform border
    ctx.strokeStyle = "#2b4ff2";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw sniper rifle
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Rifle body
    ctx.fillStyle = s.color;
    ctx.beginPath();
    ctx.roundRect(-8, -35, 16, 50, 3);
    ctx.fill();

    // Rifle barrel
    ctx.fillStyle = "#2b4ff2";
    ctx.beginPath();
    ctx.roundRect(-4, -50, 8, 15, 2);
    ctx.fill();

    // Rifle scope
    ctx.fillStyle = "#2b4ff2";
    ctx.beginPath();
    ctx.roundRect(-6, -25, 12, 8, 2);
    ctx.fill();

    // Scope lenses
    ctx.fillStyle = "#2b4ff2";
    ctx.beginPath();
    ctx.arc(-6, -21, 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#2b4ff2";
    ctx.beginPath();
    ctx.arc(6, -21, 3, 0, Math.PI * 2);
    ctx.fill();

    // Scope glow
    const pulse = Math.sin(time * 3) * 0.2 + 0.8;
    ctx.fillStyle = `rgba(0, 150, 255, ${0.4 * pulse})`;
    ctx.beginPath();
    ctx.arc(0, -21, 2, 0, Math.PI * 2);
    ctx.fill();

    // Bipod
    ctx.strokeStyle = "#2b4ff2";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-8, 15);
    ctx.lineTo(-15, 25);
    ctx.moveTo(8, 15);
    ctx.lineTo(15, 25);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as crosshair icons
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;

      // Crosshair icon
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 2, 0, Math.PI * 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(indicatorX - 3, indicatorY);
      ctx.lineTo(indicatorX + 3, indicatorY);
      ctx.moveTo(indicatorX, indicatorY - 3);
      ctx.lineTo(indicatorX, indicatorY + 3);
      ctx.stroke();
    }

    // Draw laser sight when not firing
    if (this.cool > 0.1) {
      this.drawLaserSight();
    }
  }

  drawLaserSight(target = null) {
    const s = this.spec();
    const { x, y } = this.center;
    const angle = this.rot - Math.PI / 2;

    // Calculate laser end point
    let endX, endY;
    if (target) {
      endX = target.pos.x;
      endY = target.pos.y;
    } else {
      // Extend laser to max range if no target
      endX = x + Math.cos(angle) * s.range;
      endY = y + Math.sin(angle) * s.range;
    }

    // Draw laser beam
    ctx.strokeStyle = `rgba(255, 50, 50, 0.4)`;
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 4]);
    ctx.beginPath();
    ctx.moveTo(
      x + Math.cos(angle) * 35, // Start at barrel tip
      y + Math.sin(angle) * 35
    );
    ctx.lineTo(endX, endY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw laser dot at end
    if (target) {
      ctx.fillStyle = "rgba(255, 50, 50, 0.6)";
      ctx.beginPath();
      ctx.arc(endX, endY, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}


// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\TeslaTower.js =====

// ===== FILE: C:\Users\kurd7\Downloads\Tower\src\towers\TeslaTower.js =====

import { BaseTower } from "./BaseTower.js";
import { ctx } from "../core.js";
import { enemies } from "../state.js";
import { spawnLightningArc, spawnElectricExplosion } from "../effects.js";
import { particles } from "../state.js";
import { dist } from "../utils.js";

export class TeslaTower extends BaseTower {
  static SPEC = {
    name: "Tesla Tower",
    cost: 300,
    range: 140,
    fireRate: 1.3,
    dmg: 25,
    chainCount: 3,
    chainRange: 80,
    stunChance: 0.3,
    stunDuration: 1.5,
    color: "#9d4edd",
  };

  // Override spec to include tesla properties
  spec() {
    const base = this.constructor.SPEC;
    const mult = 1 + (this.level - 1) * 0.35;
    return {
      name: base.name,
      range: base.range * (1 + (this.level - 1) * 0.08),
      fireRate: base.fireRate * (1 + (this.level - 1) * 0.05),
      dmg: base.dmg * mult,
      chainCount: base.chainCount + Math.floor(this.level / 2), // +1 chain every 2 levels
      chainRange: base.chainRange * (1 + (this.level - 1) * 0.05),
      stunChance: base.stunChance + (this.level - 1) * 0.05,
      stunDuration: base.stunDuration * (1 + (this.level - 1) * 0.1),
      color: base.color,
      cost: base.cost,
    };
  }

  update(dt, enemiesList) {
    const s = this.spec();
    this.cool -= dt;

    if (this.cool <= 0) {
      let best = null;
      let bestScore = -1;

      for (const e of enemiesList) {
        if (e.dead) continue;
        const p = e.pos;
        const d = dist(this.center, p);
        if (d <= s.range && e.t > bestScore) {
          best = e;
          bestScore = e.t;
        }
      }

      if (best) {
        this.cool = 1 / s.fireRate;
        this.rot = Math.atan2(
          best.pos.y - this.center.y,
          best.pos.x - this.center.x
        );
        this.fireLightning(best, s);
      }
    }
  }

  fireLightning(primaryTarget, spec) {
    const c = this.center;
    const hitEnemies = new Set([primaryTarget]);

    // Damage primary target
    primaryTarget.damage(spec.dmg);
    this.applyStun(primaryTarget, spec);

    // Create primary lightning arc
    spawnLightningArc(c, primaryTarget.pos, spec.color);
    spawnElectricExplosion(primaryTarget.pos.x, primaryTarget.pos.y);

    // Chain to additional targets
    let currentTarget = primaryTarget;
    for (let i = 0; i < spec.chainCount; i++) {
      const nextTarget = this.findNextChainTarget(
        currentTarget,
        hitEnemies,
        spec.chainRange
      );
      if (!nextTarget) break;

      // Damage chained target (reduced damage)
      const chainDmg = spec.dmg * (0.6 - i * 0.1); // 60%, 50%, 40%, etc.
      nextTarget.damage(chainDmg);
      this.applyStun(nextTarget, spec);

      // Create chain lightning arc
      spawnLightningArc(currentTarget.pos, nextTarget.pos, spec.color);
      spawnElectricExplosion(nextTarget.pos.x, nextTarget.pos.y);

      hitEnemies.add(nextTarget);
      currentTarget = nextTarget;
    }

    // Visual effects on the tower itself
    this.spawnElectricParticles(c.x, c.y);
  }

  findNextChainTarget(currentTarget, hitEnemies, chainRange) {
    let bestTarget = null;
    let bestDistance = Infinity;

    for (const e of enemies) {
      if (e.dead || hitEnemies.has(e)) continue;

      const d = dist(currentTarget.pos, e.pos);
      if (d <= chainRange && d < bestDistance) {
        bestTarget = e;
        bestDistance = d;
      }
    }

    return bestTarget;
  }

  applyStun(enemy, spec) {
    if (Math.random() < spec.stunChance && !enemy.stunned) {
      enemy.stunned = true;
      enemy.originalSpeed = enemy.speed;
      enemy.speed = 0;

      // Set timeout to remove stun
      setTimeout(() => {
        if (!enemy.dead) {
          enemy.stunned = false;
          enemy.speed = enemy.originalSpeed;
          enemy.electricEffect = false;
        }
      }, spec.stunDuration * 1000);

      enemy.electricEffect = true;
      enemy.electricEffectTime = spec.stunDuration;
    }
  }

  spawnElectricParticles(x, y) {
    for (let i = 0; i < 8; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 50 + Math.random() * 100;
      const size = 1 + Math.random() * 2;
      const life = 0.3 + Math.random() * 0.2;

      // Use the imported particles array instead of window.particles
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life,
        r: size,
        c: "#e0aaff",
        gravity: 0.1,
        fade: 0.9,
      });
    }
  }

  draw() {
    const s = this.spec();
    const { x, y } = this.center;
    const time = performance.now() / 1000;

    // Draw electrified base platform
    ctx.fillStyle = "#1a1426";
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.fill();

    // Electric glow effect
    const pulse = Math.sin(time * 5) * 0.2 + 0.8;
    const gradient = ctx.createRadialGradient(x, y, 10, x, y, 25);
    gradient.addColorStop(0, `rgba(157, 78, 221, ${0.6 * pulse})`);
    gradient.addColorStop(1, "rgba(157, 78, 221, 0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, Math.PI * 2);
    ctx.fill();

    // Platform border with electric effect
    ctx.strokeStyle = "#5a2d91";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Draw Tesla coil body
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);

    // Main coil base
    ctx.fillStyle = "#2a1a3a";
    ctx.beginPath();
    ctx.roundRect(-12, -14, 24, 28, 8);
    ctx.fill();

    // Tesla coil primary
    ctx.fillStyle = "#3a2a4a";
    ctx.beginPath();
    ctx.roundRect(-8, -16, 16, 32, 6);
    ctx.fill();

    // Coil windings
    ctx.strokeStyle = "#7d5ba6";
    ctx.lineWidth = 2;
    for (let i = -12; i <= 12; i += 4) {
      ctx.beginPath();
      ctx.arc(0, i, 6, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Top electrode (Tesla ball)
    ctx.fillStyle = "#e0aaff";
    ctx.beginPath();
    ctx.arc(0, -20, 6, 0, Math.PI * 2);
    ctx.fill();

    // Electric arc effect from top electrode
    const arcPulse = Math.sin(time * 10) * 2;
    ctx.strokeStyle = `rgba(224, 170, 255, ${0.7 + Math.sin(time * 15) * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, -26);
    for (let i = 0; i < 3; i++) {
      const offsetX = (Math.random() - 0.5) * 8;
      const offsetY = -30 - i * 4 + (Math.random() - 0.5) * 3;
      ctx.lineTo(offsetX, offsetY);
    }
    ctx.stroke();

    // Secondary coils
    ctx.fillStyle = "#4a3a5a";
    ctx.beginPath();
    ctx.roundRect(10, -10, 6, 20, 2);
    ctx.fill();

    ctx.beginPath();
    ctx.roundRect(-16, -10, 6, 20, 2);
    ctx.fill();

    // Energy conduits
    ctx.strokeStyle = "#9d4edd";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-8, 12);
    ctx.lineTo(-12, 16);
    ctx.moveTo(8, 12);
    ctx.lineTo(12, 16);
    ctx.stroke();

    ctx.restore();

    // Draw level indicators as electric orbs
    for (let i = 0; i < this.level; i++) {
      const indicatorX = x - 12 + i * 6;
      const indicatorY = y + 25;
      const orbPulse = Math.sin(time * 4 + i) * 0.5 + 1;

      // Energy glow
      ctx.fillStyle = `rgba(157, 78, 221, ${0.4 * orbPulse})`;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 5 * orbPulse, 0, Math.PI * 2);
      ctx.fill();

      // Main orb
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(indicatorX, indicatorY, 3, 0, Math.PI * 2);
      ctx.fill();

      // Electric spark effect for higher levels
      if (this.level > 3 && i >= this.level - 3) {
        this.drawElectricSpark(indicatorX, indicatorY, time);
      }
    }

    // Random electric arcs between tower parts
    if (Math.random() < 0.1) {
      this.drawRandomArc(x, y, time);
    }
  }

  drawElectricSpark(x, y, time) {
    const angle = Math.random() * Math.PI * 2;
    const length = 5 + Math.random() * 8;

    ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 + Math.sin(time * 20) * 0.2})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y);

    for (let i = 0; i < 3; i++) {
      const segX = x + (Math.cos(angle) * length * (i + 1)) / 3;
      const segY = y + (Math.sin(angle) * length * (i + 1)) / 3;
      const offsetX = (Math.random() - 0.5) * 3;
      const offsetY = (Math.random() - 0.5) * 3;
      ctx.lineTo(segX + offsetX, segY + offsetY);
    }

    ctx.stroke();
  }

  drawRandomArc(x, y, time) {
    const startAngle = Math.random() * Math.PI * 2;
    const endAngle = startAngle + (Math.random() - 0.5) * Math.PI;
    const startDist = 15 + Math.random() * 10;
    const endDist = 5 + Math.random() * 8;

    const startX = x + Math.cos(startAngle) * startDist;
    const startY = y + Math.sin(startAngle) * startDist;
    const endX = x + Math.cos(endAngle) * endDist;
    const endY = y + Math.sin(endAngle) * endDist;

    ctx.strokeStyle = `rgba(224, 170, 255, ${0.7 + Math.sin(time * 20) * 0.3})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(startX, startY);

    // Create jagged lightning effect
    const segments = 5;
    const dx = (endX - startX) / segments;
    const dy = (endY - startY) / segments;

    for (let i = 1; i <= segments; i++) {
      const segX = startX + dx * i;
      const segY = startY + dy * i;
      const offsetX = (Math.random() - 0.5) * 8;
      const offsetY = (Math.random() - 0.5) * 8;
      ctx.lineTo(segX + offsetX, segY + offsetY);
    }

    ctx.stroke();
  }
}
